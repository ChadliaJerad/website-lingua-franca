{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/c-reactors",
    "result": {"data":{"markdownRemark":{"id":"5bc98fa2-d635-5805-b994-21d427762194","excerpt":"WARNING: This page documents only the C target. Choose the C target language in the left sidebar to see the C code examples. In the C reactor target for Lingua…","html":"<p><span class=\"lf-cpp lf-py lf-ts lf-rs warning\"><strong>WARNING: This page documents only the C target.</strong> Choose the C target language in the left sidebar to see the C code examples.</span></p>\n<p>In the C reactor target for Lingua Franca, reactions are written in C and the code generator generates one or more standalone C programs that can be compiled and run on several platforms. It has been tested on MacOS, Linux, Windows, and at least one bare-iron embedded platforms. The single-threaded version (which you get by setting the <a href=\"/docs/handbook/target-specification#threading\"><code class=\"language-text\">threading</code> target parameter</a> to <code class=\"language-text\">false</code>) is the most portable, requiring only a handful of common C libraries (see <a href=\"#included-libraries\">Included Libraries</a> below). The multithreaded version requires a small subset of the Posix thread library (<code class=\"language-text\">pthreads</code>) and transparently executes in parallel on a multicore machine while preserving the deterministic semantics of Lingua Franca.</p>\n<p>Note that C is not a safe language. There are many ways that a programmer can circumvent the semantics of Lingua Franca and introduce nondeterminism and illegal memory accesses. For example, it is easy for a programmer to mistakenly send a message that is a pointer to data on the stack. The destination reactors will very likely read invalid data. It is also easy to create memory leaks, where memory is allocated and never freed. Here, we provide some guidelines for a style for writing reactors that will be safe.</p>\n<p><strong>NOTE:</strong> If you intend to use C++ code or import C++ libraries in the C target, we provide a special <a href=\"#the-ccpp-target\">CCpp target</a> that automatically uses a C++ compiler by default. Alternatively, you might want to use the <a href=\"/docs/handbook/cpp-reactors\">Cpp target</a>.</p>\n<h2 id=\"the-c-target-specification\" style=\"position:relative;\"><a href=\"#the-c-target-specification\" aria-label=\"the c target specification permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The C Target Specification</h2>\n<p>To have Lingua Franca generate C code, start your <code class=\"language-text\">.lf</code> file with one of the following target specifications:</p>\n<div class=\"gatsby-highlight\" data-language=\"lf\"><pre class=\"language-lf\"><code class=\"language-lf\">    <span class=\"token lf_keywords\">target</span> C <span class=\"token operator\">&lt;</span>options<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token lf_keywords\">target</span> CCpp <span class=\"token operator\">&lt;</span>options<span class=\"token operator\">></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The second form is used when you wish to use a C++ compiler to compile the generated code, thereby allowing your C reactors to call C++ code. Note that for all LF statements, the final semicolon is optional, but if you are writing your code in C, you may want to include the final semicolon for uniformity. See <a href=\"/docs/handbook/target-specification\">detailed documentation of the target options</a>.</p>\n<h2 id=\"reactions\" style=\"position:relative;\"><a href=\"#reactions\" aria-label=\"reactions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reactions</h2>\n<p>Recall that a reaction is defined within a reactor using the following syntax:</p>\n<blockquote>\n<p><strong>reaction</strong>(<em>triggers</em>) <em>uses</em> -> <em>effects</em> {=<br/> >    … target language code … <br/>\n=}</p>\n</blockquote>\n<p>In this section, we explain how <strong>triggers</strong>, <strong>uses</strong>, and <strong>effects</strong> variables work in the C target.</p>\n<h3 id=\"inputs-and-outputs\" style=\"position:relative;\"><a href=\"#inputs-and-outputs\" aria-label=\"inputs and outputs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inputs and Outputs</h3>\n<p>In the body of a reaction in the C target, the value of an input is obtained using the syntax <code class=\"language-text\">name->value</code>, where <code class=\"language-text\">name</code> is the name of the input port. To determine whether an input is present, use <code class=\"language-text\">name->is_present</code>. For example, the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Determinism.lf\">Determinism.lf</a> test case in the <a href=\"https://github.com/lf-lang/lingua-franca/tree/master/test/C\">test directory</a> includes the following reactor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Destination {\n    input x:int;\n    input y:int;\n    reaction(x, y) {=\n        int sum = 0;\n        if (x->is_present) {\n            sum += x->value;\n        }\n        if (y->is_present) {\n            sum += y->value;\n        }\n        printf(\"Received %d.\\n\", sum);\n    =}\n}</code></pre></div>\n<p>The reaction refers to the input values <code class=\"language-text\">x->value</code> and <code class=\"language-text\">y->value</code> and tests for their presence by referring to the variables <code class=\"language-text\">x->is_present</code> and <code class=\"language-text\">y->is_present</code>. If a reaction is triggered by just one input, then normally it is not necessary to test for its presence; it will always be present. But in the above example, there are two triggers, so the reaction has no assurance that both will be present.</p>\n<p>Inputs declared in the <strong>uses</strong> part of the reaction do not trigger the reaction. Consider this modification of the above reaction:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(x) y {=\n        int sum = x->value;\n        if (y->is_present) {\n            sum += y->value;\n        }\n        printf(\"Received %d.\\n\", sum);\n    =}</code></pre></div>\n<p>It is no longer necessary to test for the presence of <code class=\"language-text\">x</code> because that is the only trigger. The input <code class=\"language-text\">y</code>, however, may or may not be present at the logical time that this reaction is triggered. Hence, the code must test for its presence.</p>\n<p>The <strong>effects</strong> portion of the reaction specification can include outputs and actions. Actions will be described below. Outputs are set using a <code class=\"language-text\">SET</code> macro. For example, we can further modify the above example as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    output z:int;\n    reaction(x) y -> z {=\n        int sum = x->value;\n        if (y->is_present) {\n            sum += y->value;\n        }\n        SET(z, sum);\n    =}</code></pre></div>\n<p>The <code class=\"language-text\">SET</code> macro is shorthand for this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    z->value = sum;\n    z->is_present = true;</code></pre></div>\n<p>There are several variants of the <code class=\"language-text\">SET</code> macro, and the one you should use depends on the type of the output. The simple version shown above works for all primitive C type (int, double, etc.) as well as the <code class=\"language-text\">bool</code> and <code class=\"language-text\">string</code> types that Lingua Franca defines. For the other variants, see <a href=\"#Sending-and-Receiving-Arrays-and-Structs\">Sending and Receiving Arrays and Structs</a> below.</p>\n<p>If an output gets set more than once at any logical time, downstream reactors will see only the <em>final</em> value that is set. Since the order in which reactions of a reactor are invoked at a logical time is deterministic, and whether inputs are present depends only on their timestamps, the final value set for an output will also be deterministic.</p>\n<p>An output may even be set in different reactions of the same reactor at the same logical time. In this case, one reaction may wish to test whether the previously invoked reaction has set the output. It can check <code class=\"language-text\">name->is_present</code> to determine whether the output has been set. For example, the following reactor (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/TestForPreviousOutput.lf\">TestForPreviousOutput.lf</a>) will always produce the output 42:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor TestForPreviousOutput {\n    output out:int;\n    reaction(startup) -> out {=\n        // Set a seed for random number generation based on the current time.\n        srand(time(0));\n        // Randomly produce an output or not.\n        if (rand() % 2) {\n            SET(out, 21);\n        }\n    =}\n    reaction(startup) -> out {=\n        if (out->is_present) {\n            SET(out, 2 * out->value);\n        } else {\n            SET(out, 42);\n        }\n    =}\n}</code></pre></div>\n<p>The first reaction may or may not set the output to 21. The second reaction doubles the output if it has been previously produced and otherwise produces 42.</p>\n<h3 id=\"using-state-variables\" style=\"position:relative;\"><a href=\"#using-state-variables\" aria-label=\"using state variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using State Variables</h3>\n<p>A reactor may declare state variables, which become properties of each instance of the reactor. For example, the following reactor (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/lib/src/Count.lf\">Count.lf</a> and <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Count.lf\">CountTest.lf</a>) will produce the output sequence 1, 2, 3, … :</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Count {\n    state count:int(1);\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, self->count++);\n    =}\n}</code></pre></div>\n<p>The declaration on the second line gives the variable the name “count”, declares its type to be <code class=\"language-text\">int</code>, and initializes its value to 1. The type and initial value can be enclosed in the C-code delimiters <code class=\"language-text\">{= ... =}</code> if they are not simple identifiers, but in this case, that is not necessary.</p>\n<p><strong>NOTE</strong>: String types in C are <code class=\"language-text\">char*</code>. But, as explained below, types ending with <code class=\"language-text\">*</code> are interpreted specially to provide automatic memory management, which we generally don’t want with strings (a string that is a compile-time constant must not be freed). You could enclose the type as <code class=\"language-text\">{= char* =}</code>, but to avoid this awkwardness, the header files include a typedef that permits using <code class=\"language-text\">string</code> instead of <code class=\"language-text\">char*</code>. For an example using <code class=\"language-text\">string</code> data types, see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayString.lf\">DelayString.lf</a>.</p>\n<p>In the body of the reaction, the state variable is referenced using the syntax <code class=\"language-text\">self->count</code>. Here, <strong>self</strong> is a keyword that is provided by Lingua Franca. It refers to a struct that contains all the instance-specific data associated with an instance of the reactor. Since each instance of a reactor has its own state variables, these variables are carried in the <strong>self</strong> struct.</p>\n<p>It may be tempting to declare state variables in the <strong>preamble</strong>, as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor FlawedCount {\n    preamble {=\n        int count = 0;\n    =}\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, count++);\n    =}\n}</code></pre></div>\n<p>This will produce a sequence of integers, but if there is more than one instance of the reactor, those instances will share the same variable count. Hence, <strong>don’t do this</strong>! Sharing variables across instances of reactors violates a basic principle, which is that reactors communicate only by sending messages to one another. Sharing variables will make your program nondeterministic. If you have multiple instances of the above FlawedCount reactor, the outputs produced by each instance will not be predictable, and in a multithreaded implementation, will also not be repeatable.</p>\n<p>A state variable may be a time value, declared as follows (see for example <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SlowingClock.lf\">SlowingClock.lf</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    state time_value:time(100 msec);</code></pre></div>\n<p>The <code class=\"language-text\">self->time_value</code> variable will be of type <code class=\"language-text\">instant_t</code>, which is a <code class=\"language-text\">long long</code> and the same type as <code class=\"language-text\">interval_t</code>. The value of the variable is a number in units of nanoseconds.</p>\n<p>A state variable can have an array value. For example, the [MovingAverage] (<a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/MovingAverage.lf\">https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/MovingAverage.lf</a>) reactor computes the <strong>moving average</strong> of the last four inputs each time it receives an input:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor MovingAverageImpl {\n    state delay_line:double[](0.0, 0.0, 0.0);\n    state index:int(0);\n    input in:double;\n    output out:double;\n    reaction(in) -> out {=\n        // Calculate the output.\n        double sum = in->value;\n        for (int i = 0; i &lt; 3; i++) {\n            sum += self->delay_line[i];\n        }\n        SET(out, sum/4.0);\n\n        // Insert the input in the delay line.\n        self->delay_line[self->index] = in->value;\n\n        // Update the index for the next input.\n        self->index++;\n        if (self->index >= 3) {\n            self->index = 0;\n        }\n    =}\n}</code></pre></div>\n<p>The second line declares that the type of the state variable is an array of <code class=\"language-text\">double</code>s with the initial value of the array being a three-element array filled with zeros.</p>\n<p>States whose type are structs can similarly be initialized. See <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsState.lf\">StructAsState.lf</a>.</p>\n<h3 id=\"using-parameters\" style=\"position:relative;\"><a href=\"#using-parameters\" aria-label=\"using parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Parameters</h3>\n<p>Reactor parameters are also referenced in the C code using the <strong>self</strong> struct. The <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Stride.lf\">Stride</a> example modifies the above <code class=\"language-text\">Count</code> reactor so that its stride is a parameter:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor Count(stride:int(1)) {\n    state count:int(1);\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, self->count);\n        self->count += self->stride;\n    =}\n}\nreactor Display {\n    input x:int;\n    reaction(x) {=\n        printf(\"Received: %d.\\n\", x->value);\n    =}\n}\nmain reactor Stride {\n    c = new Count(stride = 2);\n    d = new Display();\n    c.y -> d.x;\n}</code></pre></div>\n<p>The second line defines the <code class=\"language-text\">stride</code> parameter, gives its type, and gives its initial value. As with state variables, the type and initial value can be enclosed in <code class=\"language-text\">{= ... =}</code> if necessary. The parameter is referenced in the reaction with the syntax <code class=\"language-text\">self->stride</code>.</p>\n<p>When the reactor is instantiated, the default parameter value can be overridden. This is done in the above example near the bottom with the line:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    c = new Count(stride = 2);</code></pre></div>\n<p>If there is more than one parameter, use a comma separated list of assignments.</p>\n<p>Parameters can have array values, though some care is needed. The <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsParameter.lf\">ArrayAsParameter</a> example outputs the elements of an array as a sequence of individual messages:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source(sequence:int[](0, 1, 2), n_sequence:int(3)) {\n    output out:int;\n    state count:int(0);\n    logical action next;\n    reaction(startup, next) -> out, next {=\n        SET(out, self->sequence[self->count]);\n        self->count++;\n        if (self->count &lt; self->n_sequence) {\n            schedule(next, 0);\n        }\n    =}\n}</code></pre></div>\n<p>The <strong>logical action</strong> named <code class=\"language-text\">next</code> and the <code class=\"language-text\">schedule</code> function are explained below in <a href=\"#Scheduling-Delayed-Reactions\">Scheduling Delayed Reactions</a>; here they are used simply to repeat the reaction until all elements of the array have been sent.</p>\n<p>In C, arrays do not encode their own length, so a separate parameter is used for the array length. Obviously, there is potential here for errors, where the array length doesn’t match the length parameter.</p>\n<p>Above, the parameter default value is an array with three elements, <code class=\"language-text\">[0, 1, 2]</code>. The syntax for giving this default value is that of a Lingua Franca list, <code class=\"language-text\">(0, 1, 2)</code>, which gets converted by the code generator into a C static initializer. The default value can be overridden when instantiating the reactor using a similar syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    s = new Source(sequence = (1, 2, 3, 4), n_sequence=4);</code></pre></div>\n<h3 id=\"sending-and-receiving-arrays-and-structs\" style=\"position:relative;\"><a href=\"#sending-and-receiving-arrays-and-structs\" aria-label=\"sending and receiving arrays and structs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sending and Receiving Arrays and Structs</h3>\n<p>You can define your own datatypes in C and send and receive those. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsType.lf\">StructAsType</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor StructAsType {\n    preamble {=\n        typedef struct hello_t {\n            char* name;\n            int value;\n        } hello_t;\n    =}\n    output out:hello_t;\n    reaction(startup) -> out {=\n        struct hello_t temp = {\"Earth\", 42};\n        SET(out, temp);\n    =}\n}</code></pre></div>\n<p>The <strong>preamble</strong> code defines a struct datatype. In the reaction to <strong>startup</strong>, the reactor creates an instance of this struct on the stack (as a local variable named <code class=\"language-text\">temp</code>) and then copies that struct to the output using the <code class=\"language-text\">SET</code> macro.</p>\n<p>For large structs, it may be inefficient to create a struct on the stack and copy it to the output, as done above. You can instead write directly to the fields of the struct. For example, the above reaction could be rewritten as follows (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsTypeDirect.lf\">StructAsTypeDirect</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(startup) -> out {=\n        out->value.name = \"Earth\";\n        out->value.value = 42;\n        SET_PRESENT(out);\n    =}</code></pre></div>\n<p>The final call to <code class=\"language-text\">SET_PRESENT</code> is necessary to inform downstream reactors that the struct has a new value. (This is a macro that simply does <code class=\"language-text\">out->is_present = true</code>). Note that in subsequent reactions, the values of the struct persist. Hence, this technique can be very efficient if a large struct is modified only slightly in each of a sequence of reactions.</p>\n<p>A reactor receiving the struct message uses the struct as normal in C:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:hello_t;\n    reaction(in) {=\n        printf(\"Received: name = %s, value = %d\\n\", in->value.name, in->value.value);\n    =}\n}</code></pre></div>\n<p>The preamble should not be repeated in this reactor definition if the two reactors are defined together because this will trigger an error when the compiler thinks that hello_t is being redefined.</p>\n<p>Arrays that have fixed sizes are handled similarly. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsType.lf\">ArrayAsType</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayAsType {\n    output out:int[3];\n    reaction(startup) -> out {=\n        out[0] = 0;\n        out[1] = 1;\n        out[2] = 2;\n        SET_PRESENT(out);\n    =}\n}</code></pre></div>\n<p>Here, the output is declared to have type <code class=\"language-text\">int[3]</code>, an array of three integers. The startup reaction above writes to the array and then calls <code class=\"language-text\">SET_PRESENT</code> to indicate an updated value. Again, the values in the array will persist across reactions.</p>\n<p>A reactor receiving this array is straightforward. It just references the array elements as usual in C, as illustrated by this example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:int[3];\n    reaction(in) {=\n        printf(\"Received: [\");\n        for (int i = 0; i &lt; 3; i++) {\n            if (i > 0) printf(\", \");\n            printf(\"%d\", in->value[i]);\n        }\n        printf(\"]\\n\");\n    =}\n}</code></pre></div>\n<h4 id=\"dynamically-allocated-arrays\" style=\"position:relative;\"><a href=\"#dynamically-allocated-arrays\" aria-label=\"dynamically allocated arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamically Allocated Arrays</h4>\n<p>For arrays where the size is variable, it may be necessary to dynamically allocate memory. But when should that memory be freed? A reactor cannot know when downstream reactors are done with the data. Lingua Franca provides utilities for managing this using reference counting. You can pass a pointer to a dynamically allocated object as illustrated in the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayPrint.lf\">ArrayPrint</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayPrint {\n    output out:int[];\n    reaction(startup) -> out {=\n        // Dynamically allocate an output array of length 3.\n        SET_NEW_ARRAY(out, 3);\n        // Above allocates the array, which then must be populated.\n        out[0] = 0;\n        out[1] = 1;\n        out[2] = 2;\n    =}\n}</code></pre></div>\n<p>This declares the output datatype to be <code class=\"language-text\">int[]</code> (or, equivalently, <code class=\"language-text\">int*</code>), an array of integers of unspecified size. To produce the array in a reaction, it uses the library function <code class=\"language-text\">SET_NEW_ARRAY</code> to allocate an array of length 3 and sets the output to send that array. The reaction then populates the array with data. The deallocation of the memory for the array will occur automatically after the last reactor that receives a pointer to the array has finished using it.</p>\n<p>A reactor receiving the array looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print {\n    input in:int[];\n    reaction(in) {=\n        printf(\"Received: [\");\n        for (int i = 0; i &lt; in->length; i++) {\n            if (i > 0) printf(\", \");\n            printf(\"%d\", in->value[i]);\n        }\n        printf(\"]\\n\");\n    =}\n}</code></pre></div>\n<p>In the body of the reaction, <code class=\"language-text\">in->value</code> is a pointer to first element of the array, so it can be indexed as usual with arrays in C, <code class=\"language-text\">in->value[i]</code>. Moreover, a variable <code class=\"language-text\">in->length</code> is bound to the length of the array.</p>\n<p>Although it cannot be enforced in C, the receiving reactor should not modify the values stored in the array. Inputs are logically <em>immutable</em> because there may be several recipients. Any recipient that wishes to modify the array should make a copy of it. Fortunately, a utility is provided for this pattern. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayScale.lf\">ArrayScale</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayScale(scale:int(2)) {\n    mutable input in:int[];\n    output out:int[];\n    reaction(in) -> out {=\n        for(int i = 0; i &lt; in->length; i++) {\n            in->value[i] *= self->scale;\n        }\n        SET_TOKEN(out, in->token);\n    =}\n}</code></pre></div>\n<p>Here, the input is declared <strong>mutable</strong>, which means that any reaction is free to modify the input. If this reactor is the only recipient of the array or the last recipient of the array, then this will not copy of the array but rather use the original array. Otherwise, it will use a copy.</p>\n<p>The above <code class=\"language-text\">ArrayScale</code> reactor modifies the array and then forwards it to its output port using the <code class=\"language-text\">SET_TOKEN()</code> macro. That macro further delegates to downstream reactors the responsibility for freeing dynamically allocated memory once all readers have completed their work.</p>\n<p>If the above code were not to forward the array, then the dynamically allocated memory will be automatically freed when this reactor is done with it.</p>\n<p>The above three reactors can be combined into a pipeline as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor ArrayScaleTest {\n    s = new ArrayPrint();\n    c = new ArrayScale();\n    p = new Print();\n    s.out -> c.in;\n    c.out -> p.in;\n}</code></pre></div>\n<p>In this composite, the array is allocated by <code class=\"language-text\">ArrayPrint</code>, modified by <code class=\"language-text\">ArrayScale</code>, and deallocated (freed) after <code class=\"language-text\">Print</code> has reacted. No copy is necessary because <code class=\"language-text\">ArrayScale</code> is the only recipient of the original array.</p>\n<p>Inputs and outputs can also be dynamically allocated structs. In fact, Lingua Franca’s C target will treat any input or output datatype that ends with <code class=\"language-text\">[]</code> or <code class=\"language-text\">*</code> specially by providing utilities for allocating memory and modifying and forwarding. Deallocation of the allocated memory is automatic. The complete set of utilities is given below.</p>\n<h4 id=\"macros-for-setting-output-values\" style=\"position:relative;\"><a href=\"#macros-for-setting-output-values\" aria-label=\"macros for setting output values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Macros For Setting Output Values</h4>\n<p>In all of the following, <em>out</em> is the name of the output and <em>value</em> is the value to be sent.</p>\n<blockquote>\n<p><strong>SET</strong>(<em>out</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Set the specified output (or input of a contained reactor) to the specified value. This version is used for primitive type such as `int`, `double`, etc. as well as the built-in types `bool` and `string` (but only if the string is a statically allocated constant; otherwise, see `SET_NEW_ARRAY`). It can also be used for structs with a type defined by a `typedef` so that the type designating string does not end in '*'. The value is copied and therefore the variable carrying the value can be subsequently modified without changing the output.</code></pre></div>\n<blockquote>\n<p><strong>SET_ARRAY</strong>(<em>out</em>, <em>value</em>, <em>element_size</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `[]` or `*`, such as `int[]`. This version is for use when the *value* to be sent is in dynamically allocated memory that will need to be freed downstream. The allocated memory will be automatically freed when all recipients of the outputs are done with it. Since C does not encode array sizes as part of the array, the *length* and *element_size* must be given (the latter is the size of each element in bytes). See [SetArray.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SetArray.lf).</code></pre></div>\n<blockquote>\n<p><strong>SET_NEW</strong>(<em>out</em>);\nThis version is used for outputs with a type declaration ending with <code class=\"language-text\">*</code> (see example below). This sets the <code class=\"language-text\">out</code> variable to point to newly allocated memory for storing the specified output type. After calling this function, the reaction should populate that memory with the content it intends to send to downstream reactors. This macro is equivalent to <code class=\"language-text\">SET_NEW_ARRAY(out, 1)</code>. See <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructPrint.lf\">StructPrint.lf</a></p>\n</blockquote>\n<blockquote>\n<p><strong>SET_NEW_ARRAY</strong>(<em>out</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `[]` or `*`. This sets the *out* variable to point to newly allocated memory sufficient to hold an array of the specified length containing the output type in each element. The caller should subsequently populate the array with the contents that it intends to send to downstream reactors.  See [ArrayPrint.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayPrint.lf).\n**Dynamically allocated strings:** If an output is to be a dynamically allocated string, as opposed to a static string constant, then you can use `SET_NEW_ARRAY` to allocate the memory, and the memory will be automatically freed downstream after the all users have read the string. To do this, set the output type to `char[]` or `char*` rather than `string` and call `SET_NEW_ARRAY` with the desired length. After this, *out* will point to a char array of the required length. You can then populate it with your desired string, e.g. using `snprintf()`. See [DistributedToken.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/federated/DistributedToken.lf)</code></pre></div>\n<blockquote>\n<p><strong>SET_PRESENT</strong>(<em>out</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version just sets the *out*->is_present variable corresponding to the specified output  to true. This is normally used with array outputs with fixed sizes and statically allocated structs.  In these cases, the values in the output are normally written directly to the array or struct. See [ArrayAsType.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsType.lf)</code></pre></div>\n<blockquote>\n<p><strong>SET_TOKEN</strong>(<em>out</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `*` (any pointer) or `[]` (any array). The *value* argument should be a struct of type `token_t`. This can be the trickiest form to use, but it is rarely necessary for the programmer to create their own (dynamically allocated) instance of `token_t`. Consider the [SetToken.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SetToken.lf) example:</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reactor Source {\n        output out:int*;\n        logical action a:int;\n        reaction(startup) -> a {=\n            schedule_int(a, MSEC(200), 42);\n        =}\n        reaction(a) -> out {=\n            SET_TOKEN(out, a->token);\n        =}\n    }</code></pre></div>\n<p>Here, the first reaction schedules an integer-valued action to trigger after 200 microseconds. As explained below, action payloads are carried by tokens. The second reaction grabs the token rather than the value using the syntax <code class=\"language-text\">a->token</code> (the name of the action followed by <code class=\"language-text\">->token</code>). It then forwards the token to the output. The output data type is <code class=\"language-text\">int*</code> not <code class=\"language-text\">int</code> because the token carries a pointer to dynamically allocated memory that contains the value. All inputs and outputs with types ending in <code class=\"language-text\">*</code> or <code class=\"language-text\">[]</code> are carried by tokens.</p>\n<p>All of the SET macros will overwrite any output value previously set at the same logical time and will cause the final output value to be sent to all reactors connected to the output. They also all set a local <em>out</em>->is_present variable to true. This can be used to subsequently test whether the output value has been set.</p>\n<h4 id=\"dynamically-allocated-structs\" style=\"position:relative;\"><a href=\"#dynamically-allocated-structs\" aria-label=\"dynamically allocated structs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamically Allocated Structs</h4>\n<p>The <code class=\"language-text\">SET_NEW</code> and <code class=\"language-text\">SET_TOKEN</code> macros can be used to send <code class=\"language-text\">structs</code> of arbitrary complexity. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor StructPrint {\n    preamble {=\n        typedef struct hello_t {\n            char* name;\n            int value;\n        } hello_t;\n    =}\n    output out:hello_t*;\n    reaction(startup) -> out {=\n        // Dynamically allocate an output struct.\n        SET_NEW(out);\n        // Above allocates a struct, which then must be populated.\n        out->value->name = \"Earth\";\n        out->value->value = 42;\n    =}\n}</code></pre></div>\n<p>The <strong>preamble</strong> declares a struct type <code class=\"language-text\">hello_t</code> with two fields, and the <code class=\"language-text\">SET_NEW</code> macro allocates memory to contain such a struct. The subsequent code populates that memory. A reactor receiving this struct might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:hello_t*;\n    reaction(in) {=\n        printf(\"Received: name = %s, value = %d\\n\",\n            in->value->name, in->value->value\n        );\n    =}\n}</code></pre></div>\n<p>Just as with arrays, an input with a pointer type can be declared <strong>mutable</strong>, in which case it is safe to modify the fields and forward the struct.</p>\n<p>Occasionally, you will want an input or output type to be a pointer, but you don’t want the automatic memory allocation and deallocation. A simple example is a string type, which in C is <code class=\"language-text\">char*</code>. Consider the following (erroneous) reactor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Erroneous {\n    output out:char*;\n    reaction(startup) -> out {=\n        SET(out, \"Hello World\");\n    =}\n}</code></pre></div>\n<p>An output data type that ends with <code class=\"language-text\">*</code> signals to Lingua Franca that the message is dynamically allocated and must be freed downstream after all recipients are done with it. But the “Hello World” string here is statically allocated, so an error will occur when the last downstream reactor to use this message attempts to free the allocated memory. To avoid this for strings, you can use the <code class=\"language-text\">string</code> type, defined in <code class=\"language-text\">reactor.h</code>, as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Fixed {\n    output out:string;\n    reaction(startup) -> out {=\n        SET(out, \"Hello World\");\n    =}\n}</code></pre></div>\n<p>The <code class=\"language-text\">string</code> type is equivalent to <code class=\"language-text\">char*</code>, but since it doesn’t end with <code class=\"language-text\">*</code>, it does not signal to Lingua Franca that the type is dynamically allocated. Lingua Franca only handles allocation and deallocation for types that are specified literally with a final <code class=\"language-text\">*</code> in the type name. The same trick can be used for any type where you don’t want automatic allocation and deallocation. E.g., the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SendsPointerTest.lf\">SendsPointer</a> example looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor SendsPointer  {\n    preamble {=\n        typedef int* int_pointer;\n    =}\n    output out:int_pointer;\n    reaction(startup) -> out {=\n        static int my_constant = 42;\n        SET(out, &amp;my_constant;)\n    =}\n}</code></pre></div>\n<p>The above technique can be used to abuse the reactor model of computation by communicating pointers to shared variables. This is generally a bad idea unless those shared variables are immutable. The result will likely be nondeterministic. Also, communicating pointers across machines that do not share memory will not work at all.</p>\n<h2 id=\"timed-behavior\" style=\"position:relative;\"><a href=\"#timed-behavior\" aria-label=\"timed behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Timed Behavior</h2>\n<p>Timers are specified exactly as in the <a href=\"Language-Specification#timer-declaration\">Lingua Franca language specification</a>. When working with time in the C code body of a reaction, however, you will need to know a bit about its internal representation.</p>\n<p>In the C target, the value of a time instant or interval is an integer specifying a number of nanoseconds. An instant is the number of nanoseconds that have elapsed since January 1, 1970. An interval is the difference between two instants. When an LF program starts executing, logical time is (normally) set to the instant provided by the operating system. (On some embedded platforms without real-time clocks, it will be set instead to zero.)</p>\n<p>Time in the C target is a <code class=\"language-text\">long long</code>, which is (normally) a 64 bit signed number. Since a 64-bit number has a limited range, this measure of time instants will overflow in approximately the year 2262. For better code clarity, two types are defined in <a href=\"https://github.com/lf-lang/reactor-c/blob/main/core/tag.h\">tag.h</a>, <code class=\"language-text\">instant_t</code> and <code class=\"language-text\">interval_t</code>, which you can use for time instants and intervals respectively. These are both equivalent to <code class=\"language-text\">long long</code>, but using those types will insulate your code against changes and platform-specific customizations.</p>\n<p>Lingua Franca uses a superdense model of time. A reaction is invoked at a logical <strong>tag</strong>, a struct consists of a <code class=\"language-text\">time</code> value (an <code class=\"language-text\">instant_t</code>, which is a <code class=\"language-text\">long long</code>) and a <code class=\"language-text\">microstep</code> value (a <code class=\"language-text\">microstep_t</code>, which is an unsigned <code class=\"language-text\">int</code>). The tag is guaranteed to not increase during the execution of a reaction. Outputs produced by a reaction have the same tag as the inputs, actions, or timers that trigger the reaction, and hence are <strong>logically simultaneous</strong>.</p>\n<p>The time structs and functions for working with time are defined in <a href=\"https://github.com/lf-lang/reactor-c/blob/main/core/tag.h\">tag.h</a>. The most useful functions are:</p>\n<ul>\n<li><code class=\"language-text\">tag_t get_current_tag()</code>: Get the current tag at which this reaction has been invoked.</li>\n<li><code class=\"language-text\">instant_t get_logical_time()</code>: Get the current logical time (the first part of the current tag).</li>\n<li><code class=\"language-text\">microstep_t get_microstep() </code>: Get the current microstep (the second part of the current tag).</li>\n<li><code class=\"language-text\">interval_t get_elapsed_logical_time()</code>: Get the logical time elapsed since program start.</li>\n<li><code class=\"language-text\">int compare_tags(tag_t, tag_t)</code>: Compare two tags, returning -1, 0, or 1 for less than, equal, and greater than.</li>\n</ul>\n<p>There are also some useful functions for accessing physical time:</p>\n<ul>\n<li><code class=\"language-text\">instant_t get_physical_time()</code>: Get the current physical time.</li>\n<li><code class=\"language-text\">instant_t get_elapsed_physical_time()</code>: Get the physical time elapsed since program start.</li>\n<li><code class=\"language-text\">instant_t get_start_time()</code>: Get the starting physical and logical time.</li>\n</ul>\n<p>The last of these is both a physical and logical time because, at the start of execution, the starting logical time is set equal to the current physical time as measured by a local clock.</p>\n<p>A reaction can examine the current logical time (which is constant during the execution of the reaction). For example, consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/GetTime.lf\">GetTime</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t logical = get_logical_time();\n        printf(\"Logical time is %lld.\\n\", logical);\n    =}\n}</code></pre></div>\n<p>When executed, you will get something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:18:36 2019\nplus 353609000 nanoseconds.\nLogical time is 1570987116353609000.\nLogical time is 1570987117353609000.\nLogical time is 1570987118353609000.\n...</code></pre></div>\n<p>The first two lines give the current time-of-day provided by the execution platform at the start of execution. This is used to initialize logical time. Subsequent values of logical time are printed out in their raw form, rather than the friendlier form in the first two lines. If you look closely, you will see that each number is one second larger than the previous number, where one second is 1000000000 nanoseconds.</p>\n<p>You can also obtain the <em>elapsed</em> logical time since the start of execution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        interval_t elapsed = get_elapsed_logical_time();\n        printf(\"Elapsed logical time is %lld.\\n\", elapsed);\n    =}\n}</code></pre></div>\n<p>This will produce:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:25:22 2019\nplus 833273000 nanoseconds.\nElapsed logical time is 0.\nElapsed logical time is 1000000000.\nElapsed logical time is 2000000000.\n...</code></pre></div>\n<p>You can also get physical time, which comes from your platform’s real-time clock:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t physical = get_physical_time();\n        printf(\"Physical time is %lld.\\n\", physical);\n    =}\n}</code></pre></div>\n<p>This will produce something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:35:59 2019\nplus 984992000 nanoseconds.\nPhysical time is 1570988159986108000.\nPhysical time is 1570988160990219000.\nPhysical time is 1570988161990067000.\n...</code></pre></div>\n<p>Finally, you can get elapsed physical time:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t elapsed_physical = get_elapsed_physical_time();\n        printf(\"Elapsed physical time is %lld.\\n\", elapsed_physical);\n    =}\n}</code></pre></div>\n<p>This will produce something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Elapsed physical time is 657000.\nElapsed physical time is 1001856000.\nElapsed physical time is 2004761000.\n...</code></pre></div>\n<p>Notice that these numbers are increasing by <em>roughly</em> one second each time. If you set the <code class=\"language-text\">fast</code> target parameter to <code class=\"language-text\">true</code>, then physical time will elapse much faster than logical time.</p>\n<p>Working with nanoseconds in C code can be tedious if you are interested in longer durations. For convenience, a set of macros are available to the C programmer to convert time units into the required nanoseconds. For example, you can specify 200 msec in C code as <code class=\"language-text\">MSEC(200)</code> or two weeks as <code class=\"language-text\">WEEKS(2)</code>. The provided macros are NSEC, USEC (for microseconds), MSEC, SEC, MINUTE, HOUR, DAY, and WEEK. You may also use the plural of any of these. Examples are given in the next section.</p>\n<h2 id=\"actions-with-values\" style=\"position:relative;\"><a href=\"#actions-with-values\" aria-label=\"actions with values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Actions With Values</h2>\n<p>Actions are described in the <a href=\"/docs/handbook/actions\">Actions</a>. If an action is declared with a data type, then it can carry a <strong>value</strong>, a data value that becomes available to any reaction triggered by the action. This is particularly useful for physical actions that are externally triggered because it enables the action to convey information to the reactor. This could be, for example, the body of an incoming network message or a numerical reading from a sensor.</p>\n<p>Recall from the <a href=\"language-specification#Contained-Reactors\">Contained Reactors</a> section in the Language Specification document that the <strong>after</strong> keyword on a connection between ports introduces a logical delay. This is actually implemented using a logical action. We illustrate how this is done using the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayInt.lf\">DelayInt</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayInt(delay:time(100 msec)) {\n    input in:int;\n    output out:int;\n    logical action d:int;\n    reaction(d) -> out {=\n        SET(out, d->value);\n    =}\n    reaction(in) -> d {=\n        schedule_int(d, self->delay, in->value);\n    =}\n}</code></pre></div>\n<p>Using this reactor as follows</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    d = new Delay();\n    source.out -> d.in;\n    d.in -> sink.out</code></pre></div>\n<p>is equivalent to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    source.out -> sink.in after 100 msec</code></pre></div>\n<p>(except that our <code class=\"language-text\">DelayInt</code> reactor will only work with data type <code class=\"language-text\">int</code>).</p>\n<p>The action <code class=\"language-text\">d</code> is specified with a type <code class=\"language-text\">int</code>. The reaction to the input <code class=\"language-text\">in</code> declares as its effect the action <code class=\"language-text\">d</code>. This declaration makes it possible for the reaction to schedule a future triggering of <code class=\"language-text\">d</code>. The reaction uses one of several variants of the <strong>schedule</strong> function, namely <strong>schedule_int</strong>, a convenience function provided because integer payloads on actions are very common. We will see below, however, that payloads can have any data type.</p>\n<p>The first reaction declares that it is triggered by <code class=\"language-text\">d</code> and has effect <code class=\"language-text\">out</code>. To read the value, it uses the <code class=\"language-text\">d->value</code> variable. Because this reaction is first, the <code class=\"language-text\">out</code> at any logical time can be produced before the input <code class=\"language-text\">in</code> is even known to be present. Hence, this reactor can be used in a feedback loop, where <code class=\"language-text\">out</code> triggers a downstream reactor to send a message back to <code class=\"language-text\">in</code> of this same reactor. If the reactions were given in the opposite order, there would be causality loop and compilation would fail.</p>\n<p>If you are not sure whether an action carries a value, you can test for it as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(d) -> out {=\n        if (d->has_value) {\n            SET(out, d->value);\n        }\n    =}</code></pre></div>\n<p>It is possible to both be triggered by and schedule an action the same reaction. For example, this <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/CountSelf.lf\">CountSelf</a> reactor will produce a counting sequence after it is triggered the first time:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor CountSelf(delay:time(100 msec)) {\n    output out:int;\n    logical action a:int;\n    reaction(startup) -> a, out {=\n        SET(out, 0);\n        schedule_int(a, self->delay, 1);\n    =}\n    reaction(a) -> a, out {=\n        SET(out, a->value);\n        schedule_int(a, self->delay, a->value + 1);\n    =}\n}</code></pre></div>\n<p>Of course, to produce a counting sequence, it would be more efficient to use a state variable.</p>\n<p>Actions with values can be rather tricky to use because the value must usually be carried in dynamically allocated memory. It will not work for value to refer to a state variable of the reactor because that state variable will likely have changed value by the time the reactions to the action are invoked. Several variants of the <strong>schedule</strong> function are provided to make it easier to pass values across time in varying circumstances.</p>\n<blockquote>\n<p><strong>schedule</strong>(<em>action</em>, <em>offset</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This is the simplest version as it carries no value. The action need not have a data type.</code></pre></div>\n<blockquote>\n<p><strong>schedule_int</strong>(<em>action</em>, <em>offset</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version carries an `int` value. The datatype of the action is required to be `int`.</code></pre></div>\n<blockquote>\n<p><strong>schedule_token</strong>(<em>action</em>, <em>offset</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version carries a **token**, which has type `token_t` and points to the value, which can have any type. There is a `create_token()` function that can be used to create a token, but programmers will rarely need to use this.  Instead, you can use `schedule_value()` (see below), which will automatically create a token. Alternatively, for inputs with types ending in `*` or `[]`, the value is wrapped in a token, and the token can be obtained using the syntax `inputname->token` in a reaction and then forwarded using `schedule_token()` (see section [Dynamically Allocated Structs](#Dynamically-Allocated-Structs) above). If the input is mutable, the reaction can then even modify the value pointed to by the token and/or use `schedule_token()` to send the token to a future logical time. For example, the [DelayPointer](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayPointer.lf) reactor realizes a logical delay for any datatype carried by a token:</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayPointer(delay:time(100 msec)) {\n    input in:void*;\n    output out:void*;\n    logical action a:void*;\n    reaction(a) -> out {=\n        // Using SET_TOKEN delegates responsibility for\n        // freeing the allocated memory downstream.\n        SET_TOKEN(out, a->token);\n    =}\n    reaction(in) -> a {=\n        // Schedule the actual token from the input rather than\n        // a new token with a copy of the input value.\n        schedule_token(a, self->delay, in->token);\n    =}\n}</code></pre></div>\n<blockquote>\n<p><strong>schedule_value</strong>(<em>action</em>, <em>offset</em>, <em>value</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used to send into the future a value that has been dynamically allocated malloc. It will be automatically freed when it is no longer needed. The *value* argument is a pointer to the memory containing the value. The *length* argument should be 1 if it is a not an array and the array length otherwise. This length will be needed downstream to interpret the data correctly. See [ScheduleValue.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ScheduleValue.lf).</code></pre></div>\n<blockquote>\n<p><strong>schedule_copy</strong>(<em>action</em>, <em>offset</em>, <em>value</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is for sending a copy of some data pointed to by the *value* argument. The data is assumed to be a scalar or array of type matching the *action* type. The *length* argument should be 1 if it is a not an array and the array length otherwise. This length will be needed downstream to interpret the data correctly.</code></pre></div>\n<p>Occasionally, an action payload may not be dynamically allocated nor freed. For example, it could be a pointer to a statically allocated string. If you know this to be the case, the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayString.lf\">DelayString</a> reactor will realize a logical time delay on such a string:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayString(delay:time(100 msec)) {\n    input in:string;\n    output out:string;\n    logical action a:string;\n    reaction(a) -> out {=\n        SET(out, a->value);\n    =}\n    reaction(in) -> a {=\n        // The following copies the char*, not the string.\n        schedule_copy(a, self->delay, &amp;(in->value), 1);\n    =}\n}</code></pre></div>\n<p>The datatype <code class=\"language-text\">string</code> is an alias for <code class=\"language-text\">char*</code>, but Lingua Franca does not know this, so it creates a token that contains a copy of the pointer to the string rather than a copy of the string itself.</p>\n<h2 id=\"stopping-execution\" style=\"position:relative;\"><a href=\"#stopping-execution\" aria-label=\"stopping execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stopping Execution</h2>\n<p>A reaction may request that the execution stop after all events with the current timestamp have been processed by calling the built-in function <code class=\"language-text\">request_stop()</code>, which takes no arguments. In a non-federated execution, the returned time is normally the same as the current logical time, and the actual last tag will be one microstep later. In a federated execution, however, the stop time will likely be larger than the current logical time. All federates are assured of stopping at the same logical time.</p>\n<h2 id=\"log-and-debug-information\" style=\"position:relative;\"><a href=\"#log-and-debug-information\" aria-label=\"log and debug information permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Log and Debug Information</h2>\n<p>A suite of useful functions is provided in <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/util.h\">util.h</a> for producing messages to be made visible when the generated program is run. Of course, you can always use <code class=\"language-text\">printf</code>, but this is not a good choice for logging or debug information, and it is not a good choice when output needs to be redirected to a window or some other user interface (see for example the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/C/util/sensor_simulator.h\">sensor simulator</a>). Also, [[Distributed Execution]], these functions identify which federate is producing the message. The functions are listed below. The arguments for all of these are identical to <code class=\"language-text\">printf</code> with the exception that a trailing newline is automatically added and therefore need not be included in the format string.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">DEBUG_PRINT(format, ...)</code>: Use this for verbose messages that are only needed during debugging. Nothing is printed unless the <a href=\"Language-Specification#Target-Specification\">target</a> parameter <code class=\"language-text\">logging</code> is set to <code class=\"language-text\">debug</code>. This is a macro so that overhead is minimized when nothing is to be printed.</p>\n</li>\n<li>\n<p><code class=\"language-text\">LOG_PRINT(format, ...)</code>: Use this for messages that are useful logs of the execution. Nothing is printed unless the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">target parameter <code class=\"language-text\">logging</code></a> is set to <code class=\"language-text\">log</code> or <code class=\"language-text\">debug</code>. This is a macro so that overhead is minimized when nothing is to be printed.</p>\n</li>\n<li>\n<p><code class=\"language-text\">info_print(format, ...)</code>: Use this for messages that should normally be printed but may need to be redirected to a user interface such as a window or terminal (see <code class=\"language-text\">register_print_function</code> below). These messages can be suppressed by setting the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a> to <code class=\"language-text\">warn</code> or <code class=\"language-text\">error</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">warning_print(format, ...)</code>: Use this for warning messages. These messages can be suppressed by setting the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a> to <code class=\"language-text\">error</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">error_print(format, ...)</code>: Use this for error messages. These messages are not suppressed by any <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">error_print_and_exit(format, ...)</code>: Use this for catastrophic errors.</p>\n</li>\n</ul>\n<p>In addition, a utility function is provided to register a function to redirect printed outputs:</p>\n<ul>\n<li><code class=\"language-text\">register_print_function(function)</code>: Register a function that will be used instead of <code class=\"language-text\">printf</code> to print messages generated by any of the above functions. The function should accept the same arguments as <code class=\"language-text\">printf</code>.</li>\n</ul>\n<h2 id=\"implementation-details\" style=\"position:relative;\"><a href=\"#implementation-details\" aria-label=\"implementation details permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Implementation Details</h2>\n<h3 id=\"included-libraries\" style=\"position:relative;\"><a href=\"#included-libraries\" aria-label=\"included libraries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Included Libraries</h3>\n<p>The generated code includes the following standard C libraries, so there is no need for a reactor definition to explicitly include them if they are needed:</p>\n<ul>\n<li>stdio.h</li>\n<li>stdlib.h</li>\n<li>string.h</li>\n<li>time.h</li>\n<li>errno.h</li>\n</ul>\n<p>In addition, the multithreaded implementation uses</p>\n<ul>\n<li>pthread.h</li>\n</ul>\n<h3 id=\"single-threaded-implementation\" style=\"position:relative;\"><a href=\"#single-threaded-implementation\" aria-label=\"single threaded implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single Threaded Implementation</h3>\n<p>The runtime library for the single-threaded implementation is in the following files:</p>\n<ul>\n<li>reactor.c</li>\n<li>reactor_common.c (included in the above using #include)</li>\n<li>pqueue.c</li>\n</ul>\n<p>Three header files provide the interfaces:</p>\n<ul>\n<li>reactor.h</li>\n<li>ctarget.h</li>\n<li>pqueue.h</li>\n</ul>\n<p>The strategy is to have two queues of pending accessor invocations, one that is sorted by timestamp (the event queue) and one that is sorted by priority (the reaction queue). Execution proceeds as follows:</p>\n<ol>\n<li>\n<p>At initialization, an event for each timer is put on the event queue and logical time is initialized to the current time, represented as the number of nanoseconds elapsed since January 1, 1970.</p>\n</li>\n<li>\n<p>At each logical time, pull all events from event queue that have the same earliest time stamp, find the reactions that these events trigger, and put them on the reaction queue. If there are no events on the event queue, then exit the program (unless the <code class=\"language-text\">--keepalive true</code> command-line argument is given).</p>\n</li>\n<li>\n<p>Wait until physical time matches or exceeds that earliest timestamp (unless the <code class=\"language-text\">--fast true</code> command-line argument is given). Then advance logical time to match that earliest timestamp.</p>\n</li>\n<li>\n<p>Execute reactions in order of priority from the reaction queue. These reactions may produce outputs, which results in more events getting put on the reaction queue. Those reactions are assured of having lower priority than the reaction that is executing. If a reaction calls <code class=\"language-text\">schedule()</code>, an event will be put on the event queue, not the reaction queue.</p>\n</li>\n<li>\n<p>When the reaction queue is empty, go to 2.</p>\n</li>\n</ol>\n<h3 id=\"multithreaded-implementation\" style=\"position:relative;\"><a href=\"#multithreaded-implementation\" aria-label=\"multithreaded implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multithreaded Implementation</h3>\n<p>The runtime library for the multithreaded implementation is in the following files:</p>\n<ul>\n<li>reactor_threaded.c</li>\n<li>reactor_common.c (included in the above using #include)</li>\n<li>pqueue.c</li>\n</ul>\n<p>The same two header files provide the interfaces:</p>\n<ul>\n<li>reactor.h</li>\n<li>pqueue.h</li>\n</ul>\n<p>The default number of worker threads is given by the <code class=\"language-text\">threads</code> argument in the <a href=\"#The-C-Target\">target</a> statement.\nThis can be overridden with the <code class=\"language-text\">--workers</code> <a href=\"#command-line-arguments\">command-line argument</a>.</p>\n<p>Upon initialization, the main thread will create the specified number of worker threads.\nA good choice is for this number to match the number of available cores.\nExecution proceeds in a manner similar to the <a href=\"single-threaded-implementation\">single threaded implementation</a>\nexcept that the worker threads concurrently draw reactions from the reaction queue.\nThe execution algorithm ensures that no reaction executes until all reactions that it depends on that are also\non the reaction queue have executed at the current logical time.</p>\n<p>FIXME: Describe the algorithm exploiting parallelism.</p>\n<h2 id=\"reactors-on-patmos\" style=\"position:relative;\"><a href=\"#reactors-on-patmos\" aria-label=\"reactors on patmos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reactors on Patmos</h2>\n<p>Reactors can be executed on <a href=\"https://github.com/t-crest/patmos\">Patmos</a>, a bare-metal execution platform\nthat is optimized for time-predictable execution. Well written C programs can be analyzed for their\nworst-case execution time (WCET).</p>\n<h3 id=\"compiling-and-running-reactors\" style=\"position:relative;\"><a href=\"#compiling-and-running-reactors\" aria-label=\"compiling and running reactors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compiling and Running Reactors</h3>\n<p>Patmos can run in an FPGA, but there are also two\nsimulators available:</p>\n<ol>\n<li><code class=\"language-text\">pasim</code> a software ISA simulator that is written in C++.</li>\n<li><code class=\"language-text\">patemu</code> a cycle-accurate hardware emulator generated from the hardware description.</li>\n</ol>\n<p>To execute reactions on Patmos, the <a href=\"https://github.com/t-crest/patmos\">Patmos toolchain</a> needs\nto be installed. The web page contains a quick start, detailed information including how to\nperform WCET analysis is available in the\n<a href=\"http://patmos.compute.dtu.dk/patmos_handbook.pdf\">Patmos Reference Handbook</a>.</p>\n<p>To execute the “hello world” reactor on Patmos use the LF compiler to generate the C code.\nCompile the reactor with the Patmos compiler (in <code class=\"language-text\">src-gen</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patmos-clang Minimal.c -o Minimal.elf</code></pre></div>\n<p>The reactor can be executed on the SW simulator with:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pasim Minimal.elf</code></pre></div>\n<p>As Patmos is a bare metal runtime that has no notion of calendar time, its start time\nis considered the epoch and the following output will be observed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Thu Jan  1 00:00:00 1970\nplus 640000 nanoseconds.\nHello World.\nElapsed logical time (in nsec): 0\nElapsed physical time (in nsec): 3970000</code></pre></div>\n<p>The reactor can also be executed on the hardware emulator of Patmos:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patemu Minimal.elf</code></pre></div>\n<p>This execution is considerably slower than the SW simulator, as the concrete hardware\nof Patmos is simulated cycle-accurate.</p>\n<h3 id=\"worst-case-execution-time-analysis\" style=\"position:relative;\"><a href=\"#worst-case-execution-time-analysis\" aria-label=\"worst case execution time analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Worst-Case Execution Time Analysis</h3>\n<p>Following example is a code fragment from\n<a href=\"https://github.com/lf-lang/lingua-franca/blob/master/xtext/org.icyphy.linguafranca/src/test/C/src/Wcet.lf\">Wcet.lf</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Work {\n    input in1: int;\n    input in2: int;\n    output out:int;\n    reaction(in1, in2) -> out {=\n    \tint ret;\n    \tif (in1 > 10) {\n    \t\tret = in2 * in1;\n    \t} else {\n    \t\tret = in2 + in1;\n    \t}\n        SET(out, ret);\n    =}\n}</code></pre></div>\n<p>We want to perform WCET analysis of the single reaction of the Work reactor.\nThis reaction, depending on the input data, will either perform a multiplication,\nwhich is more expensive in Patmos, or an addition. The WCET analysis shall consider\nthe multiplication path as the worst-case path. To generate the information for\nWCET analysis by the compiler we have to compile the application as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patmos-clang -O2 -mserialize=wcet.pml Wcet.c</code></pre></div>\n<p>We investigate the C source code <code class=\"language-text\">Wcet.c</code> and find that the reaction we\nare interested is named <code class=\"language-text\">reaction_function1</code>. Therefore, we invoke WCET analysis\nas follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">platin wcet -i wcet.pml -b a.out -e reaction_function1 --report</code></pre></div>\n<p>This results in following report:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n[platin] INFO: Finished run WCET analysis (platin)          in 62 ms\n[platin] INFO: best WCET bound: 242 cycles\n---\n- analysis-entry: reaction_function1\n  source: platin\n  cycles: 242\n...</code></pre></div>\n<p>The analysis gives the WCET of 242 clock cycles for the reaction,\nwhich includes clock cycles for data cache misses.\nFurther details on the WCET analysis\ntool <code class=\"language-text\">platin</code> and e.g., how to annotate loop bounds can be found in the\n<a href=\"http://patmos.compute.dtu.dk/patmos_handbook.pdf\">Patmos Reference Handbook</a>.</p>\n<p>Note, that the WCET analysis of a reaction does only include the code of the\nreaction function, not the cache miss cost of calling the function from\nthe scheduler or the cache miss cost when returning to the scheduler.</p>\n<h2 id=\"the-ccpp-target\" style=\"position:relative;\"><a href=\"#the-ccpp-target\" aria-label=\"the ccpp target permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The CCpp Target</h2>\n<p>In some cases, it might be needed or desirable to mix C and C++ code, including in the body of reactions, or in included libraries and header files. The C target uses a C compiler by default, and will fail to compile mixed C/C++ language programs. As a remedy, we offer a <code class=\"language-text\">CCpp</code> target that uses the C runtime but employs a C++ compiler to compile your program. To use it, simply replace <code class=\"language-text\">target C</code> with <code class=\"language-text\">target CCpp</code>.</p>\n<p>Here is a minimal example of a program written in the <code class=\"language-text\">CCpp</code> target, taken from <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/HelloWorldCCPP.lf\">HelloWorldCCPP.lf</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target CCpp;\nreactor HelloWorld {\n    preamble {=\n        #include &lt;iostream> // Note that no C++ header will be included by default.\n    =}\n    reaction(startup) {=\n        std::cout &lt;&lt; \"Hello World.\" &lt;&lt; std::endl;\n    =}\n}\nmain reactor {\n    a = new HelloWorld();\n}</code></pre></div>\n<p><strong>Note:</strong> Unless some <a href=\"Support-Matrix\">feature</a> in the C target is needed, we recommend using the <a href=\"Writing-Reactors-in-Cpp\">Cpp target</a> that uses a runtime that is written natively in C++.</p>\n<p><strong>Note:</strong> A <code class=\"language-text\">.lf</code> file that uses the <code class=\"language-text\">CCpp</code> target cannot and should not be imported to an <code class=\"language-text\">.lf</code> file that uses the <code class=\"language-text\">C</code> target. Although these two targets use essentially the same runtime, such a scenario can cause unintended compiler errors.</p>","headings":[{"value":"The C Target Specification","depth":2},{"value":"Reactions","depth":2},{"value":"Inputs and Outputs","depth":3},{"value":"Using State Variables","depth":3},{"value":"Using Parameters","depth":3},{"value":"Sending and Receiving Arrays and Structs","depth":3},{"value":"Dynamically Allocated Arrays","depth":4},{"value":"Macros For Setting Output Values","depth":4},{"value":"Dynamically Allocated Structs","depth":4},{"value":"Timed Behavior","depth":2},{"value":"Actions With Values","depth":2},{"value":"Stopping Execution","depth":2},{"value":"Log and Debug Information","depth":2},{"value":"Implementation Details","depth":2},{"value":"Included Libraries","depth":3},{"value":"Single Threaded Implementation","depth":3},{"value":"Multithreaded Implementation","depth":3},{"value":"Reactors on Patmos","depth":2},{"value":"Compiling and Running Reactors","depth":3},{"value":"Worst-Case Execution Time Analysis","depth":3},{"value":"The CCpp Target","depth":2}],"frontmatter":{"permalink":"/docs/handbook/c-reactors","title":"C Reactors","oneline":"Writing reactors using the C target in Lingua Franca.","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Target Specification","oneline":"The target specification in Lingua Franca.","permalink":"/docs/handbook/target-specification"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Future Proof Package/Import System","oneline":"A future proof package and import system","permalink":"/docs/handbook/proof-import"}}}},"pageContext":{"id":"3-c-reactors","slug":"/docs/handbook/c-reactors","repoPath":"/packages/documentation/copy/en/reference/C Reactors.md","previousID":"062ea964-c57a-5cd6-8a49-25f895d2d328","lang":"en","modifiedTime":"2022-04-12T00:49:47.587Z"}},
    "staticQueryHashes": []}
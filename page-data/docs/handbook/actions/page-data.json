{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/actions",
    "result": {"data":{"markdownRemark":{"id":"acb100f2-5131-57e7-9f1b-314b9b7c1ed7","excerpt":"Action Declaration An action, like an input, can cause reactions to be invoked. Whereas inputs are provided by other reactors, actions are scheduled by this…","html":"<h3 id=\"action-declaration\" style=\"position:relative;\"><a href=\"#action-declaration\" aria-label=\"action declaration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Action Declaration</h3>\n<p>An <strong>action</strong>, like an input, can cause reactions to be invoked. Whereas inputs are provided by other reactors, actions are scheduled by this reactor itself, either in response to some observed external event or as a delayed response to some input event. The action can be scheduled by a reactor by invoking a <a href=\"#scheduling-future-reactions\"><strong>schedule</strong> function</a> in a reaction or in an asynchronous callback function.</p>\n<p>An action declaration is either physical or logical:</p>\n<blockquote>\n<p><strong>physical action</strong> <em>name</em>(<em>min_delay</em>, <em>min_spacing</em>, <em>policy</em>):<em>type</em>;<br> > <strong>logical action</strong> <em>name</em>(<em>min_delay</em>, <em>min_spacing</em>, <em>policy</em>):<em>type</em>;<br></p>\n</blockquote>\n<p>The <em>min_delay</em>, <em>min_spacing</em>, and <em>policy</em> are all optional. If only one argument is given in parentheses, then it is interpreted as an <em>min_delay</em>, if two are given, then they are interpreted as <em>min_delay</em> and <em>min_spacing</em>, etc. The <em>min_delay</em> and <em>min_spacing</em> have to be a time value. The <em>policy</em> argument is a string that can be one of the following: <code class=\"language-text\">'defer'</code> (default), <code class=\"language-text\">'drop'</code>, or <code class=\"language-text\">'replace'</code>.</p>\n<p>An action will trigger at a logical time that depends on the arguments given to the schedule function, the <em>min_delay</em>, <em>min_spacing</em>, and <em>policy</em> arguments above, and whether the action is physical or logical.</p>\n<p>If the <strong>logical</strong> keyword is given, then the tag assigned to the event resulting from a call to <a href=\"#scheduling-future-reactions\"><strong>schedule</strong> function</a> is computed as follows. First, let <em>t</em> be the <em>current logical time</em>. For a logical action, the <code class=\"language-text\">schedule</code> function must be invoked from within a reaction (synchronously), so <em>t</em> is just the logical time of that reaction.</p>\n<p>The (preliminary) tag of the action is then just <em>t</em> plus <em>min_delay</em> plus the <em>offset</em> argument to <a href=\"#scheduling-future-reactions\"><strong>schedule</strong> function</a>.</p>\n<p>If the <strong>physical</strong> keyword is given, then the physical clock on the local platform is used as the timestamp assigned to the action. Moreover, for a physical action, unlike a logical action, the <code class=\"language-text\">schedule</code> function can be invoked from outside of any reaction (asynchronously), e.g. from an interrupt service routine or callback function.</p>\n<p>If a <em>min_spacing</em> has been declared, then a minimum distance between the tags of two subsequently scheduled events on the same action is enforced. If the preliminary tag is closer to the tag of the previously scheduled event (if there is one), then <em>policy</em> determines how the given constraints is enforced.</p>\n<ul>\n<li><code class=\"language-text\">'drop'</code>: the new event is dropped and <code class=\"language-text\">schedule</code> returns without having modified the event queue.</li>\n<li><code class=\"language-text\">'replace'</code>: the payload of the new event is assigned to the preceding event if it is still pending in the event queue; no new event is added to the event queue in this case. If the preceding event has already been pulled from the event queue, the default <code class=\"language-text\">'defer'</code> policy is applied.</li>\n<li><code class=\"language-text\">'defer'</code>: the event is added to the event queue with a tag that is equal to earliest time that satisfies the minimal spacing requirement. Assuming the tag of the preceding event is <em>t_prev</em>, then the tag of the new event simply becomes <em>t_prev</em> + <em>min_spacing</em>.</li>\n</ul>\n<p>Note that while the <code class=\"language-text\">'defer'</code> policy is conservative in the sense that it does not discard events, it could potentially cause an unbounded growth of the event queue.</p>\n<p>In all cases, the logical time of a new event will always be strictly greater than the logical time at which it is scheduled by at least one microstep (see the <a href=\"#Time\">Time</a> section).</p>\n<p>The default <em>min_delay</em> is zero. The default <em>min_spacing</em> is undefined (meaning that no minimum spacing constraint is enforced). If a <code class=\"language-text\">min_spacing</code> is defined, it has to be strictly greater than zero, and greater than or equal to the time precision of the target (for the C target, it is one nanosecond).</p>\n<p>The <em>min_delay</em> parameter in the <strong>action</strong> declaration is static (set at compile time), while the <em>offset</em> parameter given to the schedule function may be dynamically set at runtime. Hence, for static analysis and scheduling, the <strong>action</strong>’s’ <em>min_delay</em> parameter can be assumed to be a <em>minimum delay</em> for analysis purposes.</p>\n<h2 id=\"superdense-time\" style=\"position:relative;\"><a href=\"#superdense-time\" aria-label=\"superdense time permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Superdense Time</h2>\n<p>The model of time in Lingua Franca is a bit more sophisticated than we have hinted at. Specifically, a <strong>superdense</strong> model of time is used. In particular, instead of a <strong>timestamp</strong>, LF uses a <strong>tag</strong>, which consists of a <strong>logical time</strong> <em>t</em> and a <strong>microstep</strong> <em>m</em>. Two events are logically <strong>simultaneous</strong> only if <em>both</em> the logical time and the microstep are equal. But only the logical time is used to align behavior with physical time. For that purpose, the microstep is ignored.</p>\n<h4 id=\"discussion\" style=\"position:relative;\"><a href=\"#discussion\" aria-label=\"discussion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Discussion</h4>\n<p>Logical actions are used to schedule events at a future logical time relative to the current logical time. Physical time is ignored. They must be scheduled within reactions, and the timestamp of the scheduled event will be relative to the current logical time of the reaction that schedules them. It is an error to schedule a logical action asynchronously, outside of the context of a reaction. Asynchronous actions are required to be <strong>physical</strong>.</p>\n<p>Physical actions are typically used to assign timestamps to externally triggered events, such as the arrival of a network message or the acquisition of sensor data, where the time at which these external events occurs is of interest. There are (at least) three interesting use cases:</p>\n<ol>\n<li>An asynchronous event, such as a callback function or interrupt service routine (ISR), is invoked at a physical time <em>t</em> and schedules an action with timestamp <em>T</em>=<em>t</em>. To get this behavior, just set the physical action to have <em>min_delay</em> = 0 and call the schedule function with <em>offset</em> = 0. The <em>min_spacing</em> can be useful here to prevent these external events from overwhelming the software system.</li>\n<li>A periodic task that is occasionally modified by a sporadic sensor. In this case, you can set <em>min_delay</em> = <em>period</em> and call schedule with <em>offset</em> = 0. The resulting timestamp of the sporadic sensor event will always align with the periodic events. This is similar to periodic polling, but without the overhead of polling the sensor when nothing interesting is happening.</li>\n<li>You can impose a minimum physical time delay between an event’s occurrence, such as a push of a button, and system response by adjusting the <em>offset</em>.</li>\n</ol>\n<h3 id=\"actions-with-values\" style=\"position:relative;\"><a href=\"#actions-with-values\" aria-label=\"actions with values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Actions With Values</h3>\n<p>If an action is declared with a <em>type</em>, then it can carry a <strong>value</strong>, a data value passed to the <strong>schedule</strong> function. This value will be available to any reaction that is triggered by the action. The specific mechanism, however, is target-language dependent. See the <a href=\"Writing-reactors-in-C#actions-with-values\">C target</a> for an example.</p>\n<h3 id=\"scheduling-future-reactions\" style=\"position:relative;\"><a href=\"#scheduling-future-reactions\" aria-label=\"scheduling future reactions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scheduling Future Reactions</h3>\n<p>Each target language provides some mechanism for scheduling future reactions. Typically, this takes the form of a <code class=\"language-text\">schedule</code> function that takes as an argument an <a href=\"#Action-Declaration\">action</a>, a time interval, and (perhaps optionally), a payload. For example, in the <a href=\"Writing-Reactors-in-C#Reaction-Body\">C target</a>, in the following program, each reaction to the timer <code class=\"language-text\">t</code> schedules another reaction to occur 100 msec later:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nmain reactor Schedule {\n    timer t(0, 1 sec);\n    logical action a;\n    reaction(t) -> a {=\n        schedule(a, MSEC(100));\n    =}\n    reaction(a) {=\n        printf(\"Nanoseconds since start: %lld.\\n\", get_elapsed_logical_time());\n    =}\n}</code></pre></div>\n<p>When executed, this will produce the following output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Aug 11 04:11:57 2019\nplus 919310000 nanoseconds.\nNanoseconds since start: 100000000.\nNanoseconds since start: 1100000000.\nNanoseconds since start: 2100000000.\n...</code></pre></div>\n<p>This action has no datatype and carries no value, but, as explained below, an action can carry a value.</p>\n<h3 id=\"asynchronous-callbacks\" style=\"position:relative;\"><a href=\"#asynchronous-callbacks\" aria-label=\"asynchronous callbacks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Asynchronous Callbacks</h3>\n<p>In targets that support multitasking, the <code class=\"language-text\">schedule</code> function, which schedules future reactions, may be safely invoked on a <strong>physical action</strong> in code that is not part of a reaction. For example, in the multithreaded version of the <a href=\"Writing-Reactors-in-C#Reaction-Body\">C target</a>, <code class=\"language-text\">schedule</code> may be invoked in an interrupt service routine. The reaction(s) that are scheduled are guaranteed to occur at a time that is strictly larger than the current logical time of any reactions that are being interrupted.</p>\n<h3 id=\"superdense-time-1\" style=\"position:relative;\"><a href=\"#superdense-time-1\" aria-label=\"superdense time 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Superdense Time</h3>\n<p>Lingua Franca uses a concept known as <strong>superdense time</strong>, where two time values that appear to be the same are not logically simultaneous. At every logical time value, for example midnight on January 1, 1970, there exist a logical sequence of <strong>microsteps</strong> that are not simultaneous. The <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Microsteps.lf\">Microsteps</a> example illustrates this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor Destination {\n    input x:int;\n    input y:int;\n    reaction(x, y) {=\n        printf(\"Time since start: %lld.\\n\", get_elapsed_logical_time());\n        if (x->is_present) {\n            printf(\"  x is present.\\n\");\n        }\n        if (y->is_present) {\n            printf(\"  y is present.\\n\");\n        }\n    =}\n}\nmain reactor Microsteps {\n    timer start;\n    logical action repeat;\n    d = new Destination();\n    reaction(start) -> d.x, repeat {=\n        SET(d.x, 1);\n        schedule(repeat, 0);\n    =}\n    reaction(repeat) -> d.y {=\n        SET(d.y, 1);\n    =}\n}</code></pre></div>\n<p>The <code class=\"language-text\">Destination</code> reactor has two inputs, <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code>, and it simply reports at each logical time where either is present what is the logical time and which is present. The <code class=\"language-text\">Microsteps</code> reactor initializes things with a reaction to the one-time timer event <code class=\"language-text\">start</code> by sending data to the <code class=\"language-text\">x</code> input of <code class=\"language-text\">Destination</code>. It then schedules a <code class=\"language-text\">repeat</code> action.</p>\n<p>Note that time delay in the call to <code class=\"language-text\">schedule</code> is zero. However, any reaction scheduled by <code class=\"language-text\">schedule</code> is required to occur <strong>strictly later</strong> than current logical time. In Lingua Franca, this is handled by scheduling the <code class=\"language-text\">repeat</code> reaction to occur one <strong>microstep</strong> later. The output printed, therefore, will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Time since start: 0.\n  x is present.\nTime since start: 0.\n  y is present.</code></pre></div>\n<p>Note that the numerical time reported by <code class=\"language-text\">get_elapsed_logical_time()</code> has not advanced in the second reaction, but the fact that <code class=\"language-text\">x</code> is not present in the second reaction proves that the first reaction and the second are not logically simultaneous. The second occurs one microstep later.</p>\n<p>Note that it is possible to write code that will prevent logical time from advancing except by microsteps. For example, we could replace the reaction to <code class=\"language-text\">repeat</code> in <code class=\"language-text\">Main</code> with this one:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(repeat) -> d.y, repeat {=\n        SET(d.y, 1);\n        schedule(repeat, 0);\n    =}</code></pre></div>\n<p>This would create what is known as a <strong>stuttering Zeno</strong> condition, where logical time cannot advance. The output will be an unbounded sequence like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Time since start: 0.\n  x is present.\nTime since start: 0.\n  y is present.\nTime since start: 0.\n  y is present.\nTime since start: 0.\n  y is present.\n...</code></pre></div>\n<h3 id=\"startup-and-shutdown-reactions\" style=\"position:relative;\"><a href=\"#startup-and-shutdown-reactions\" aria-label=\"startup and shutdown reactions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Startup and Shutdown Reactions</h3>\n<p>Two special triggers are supported, <strong>startup</strong> and <strong>shutdown</strong>. A reaction that specifies the <strong>startup</strong> trigger will be invoked at the start of execution of the model. The following two syntaxes have exactly the same effect:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(startup) {= ... =}</code></pre></div>\n<p>and</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    timer t;\n    reaction(t) {= ... =}</code></pre></div>\n<p>In other words, <strong>startup</strong> is a timer that triggers once at the first logical time of execution. As with any other reaction, the reaction can also be triggered by inputs and can produce outputs or schedule actions.</p>\n<p>The <strong>shutdown</strong> trigger is slightly different. A shutdown reaction is specified as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   reaction(shutdown) {= ... =}</code></pre></div>\n<p>This reaction will be invoked when the program terminates normally (there are no more events, some reaction has called a <code class=\"language-text\">request_stop()</code> utility provided in the target language, or the execution was specified to last a finite logical time). The reaction will be invoked at a logical time one microstep <em>later</em> than the last logical time of the execution. In other words, the presence of this reaction means that the program will execute one extra logical time cycle beyond what it would have otherwise, and that logical time is one microstep later than what would have otherwise been the last logical time.</p>\n<p>If the reaction produces outputs, then downstream reactors will also be invoked at that later logical time. If the reaction schedules future reactions, those will be ignored. After the completion of this final logical time cycle, one microstep later than the normal termination, the program will exit.</p>","headings":[{"value":"Action Declaration","depth":3},{"value":"Superdense Time","depth":2},{"value":"Discussion","depth":4},{"value":"Actions With Values","depth":3},{"value":"Scheduling Future Reactions","depth":3},{"value":"Asynchronous Callbacks","depth":3},{"value":"Superdense Time","depth":3},{"value":"Startup and Shutdown Reactions","depth":3}],"frontmatter":{"permalink":"/docs/handbook/actions","title":"Actions","oneline":"Actions in Lingua Franca.","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Extending Reactors","oneline":"Extending reactors in Lingua Franca.","permalink":"/docs/handbook/extending-reactors"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Deadlines","oneline":"Deadlines in Lingua Franca.","permalink":"/docs/handbook/deadlines"}}}},"pageContext":{"id":"1-actions","slug":"/docs/handbook/actions","repoPath":"/packages/documentation/copy/en/topics/Actions.md","previousID":"0330e7d8-a106-5833-b0c0-6e33d1965b87","nextID":"80290896-42bf-55d5-ac00-03bdac92e9e2","lang":"en","modifiedTime":"2022-03-30T14:09:54.043Z"}},
    "staticQueryHashes": []}
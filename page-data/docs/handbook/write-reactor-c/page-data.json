{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/write-reactor-c",
    "result": {"data":{"markdownRemark":{"id":"febbfec1-d8e6-5525-9c2a-4deae67640b0","excerpt":"NOTE: Removed text here as it gets moved to the Writing Reactors section. See the Wiki pages for the original form of this page. In the C reactor target for…","html":"<p>NOTE: Removed text here as it gets moved to the Writing Reactors section. See the Wiki pages for the original form of this page.</p>\n<p>In the C reactor target for Lingua Franca, reactions are written in C and the code generator generates a standalone C program that can be compiled and run on several platforms. It has been tested on MacOS, Linux, Windows, and at least one bare-iron embedded platforms. The single-threaded version is the most portable, requiring only a handful of common C libraries (see <a href=\"#included-libraries\">Included Libraries</a> below). The multithreaded version requires a small subset of the Posix thread library (<code class=\"language-text\">pthreads</code>) and transparently executes in parallel on a multicore machine while preserving the deterministic semantics of Lingua Franca.</p>\n<p>Note that C is not a safe language. There are many ways that a programmer can circumvent the semantics of Lingua Franca and introduce nondeterminism and illegal memory accesses. For example, it is easy for a programmer to mistakenly send a message that is a pointer to data on the stack. The destination reactors will very likely read invalid data. It is also easy to create memory leaks, where memory is allocated and never freed. Here, we provide some guidelines for a style for writing reactors that will be safe.</p>\n<p><strong>NOTE:</strong> If you intend to use C++ code or import C++ libraries in the C target, we provide a special <a href=\"#the-ccpp-target\">CCpp target</a> that automatically uses a C++ compiler by default. Alternatively, you might want to look at the native <a href=\"Writing-Reactors-in-Cpp\">Cpp</a> target, built for C++ code if features such as <a href=\"Distributed-Execution\">federated execution</a> are not needed.</p>\n<p>It is also possible to run the executable from within the Eclipse IDE. To do this, bring up the menu on the green run button in the toolbar and select <code class=\"language-text\">External Tools Configurations...</code>. Select <code class=\"language-text\">Program</code> and click the New Configuration button. Fill out the dialog as follows (the first item is in the Variables menu and the second can be obtained by clicking on Browse Workspace, so you don’t have to type them in):</p>\n<p><img src=\"../../../../../../img/ExternalToolsConfiguration.png\" alt=\"\"></p>\n<p>You can then select the binary in the Project Explorer and, using the green Run button at the top, choose RunSelectedBinary. The output will go to the console.</p>\n<h2 id=\"the-c-target-specification\" style=\"position:relative;\"><a href=\"#the-c-target-specification\" aria-label=\"the c target specification permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The C Target Specification</h2>\n<p>To have Lingua Franca generate C code, start your <code class=\"language-text\">.lf</code> file with the following target specification:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;</code></pre></div>\n<p>A C target specification may optionally specify any of the parameters given in the [[target specification]]. For example, for the C target, in a source file named Foo.lf, you might specify:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    fast: true,\n    timeout: 10 secs\n};</code></pre></div>\n<p>The <code class=\"language-text\">fast</code> option given above specifies to execute the file as fast as possible, ignoring timing delays.</p>\n<p>The <code class=\"language-text\">timeout</code> option specifies to stop after 10 seconds of logical time have elapsed. All events at logical time 10 seconds that have microstep 0 will be processed, but not events with later tags. If any reactor calls <code class=\"language-text\">request_stop</code> before this logical time, then the program may stop at an earlier logical time. If no timeout is specified and <code class=\"language-text\">request_stop</code> is not called, then the program will continue to run until stopped by some other mechanism (such as Control-C).</p>\n<p>In addition, the C target supports the following parameters:</p>\n<ul>\n<li><a href=\"#threads\"><strong>threads</strong></a>: The number of worker threads to create to run reactions.</li>\n<li><a href=\"#cmake\"><strong>cmake</strong></a>: Enable or disable the CMake-based build system (the default is <code class=\"language-text\">true</code>).</li>\n<li><a href=\"#cmake-include\"><strong>cmake-include</strong></a>: Optionally append additional custom CMake instructions to the generated <code class=\"language-text\">CMakeLists.txt</code> from a text file.</li>\n</ul>\n<p>These target specifications specify the <em>default</em> behavior of the generated code, the behavior it will exhibit if you give no command-line options. The <code class=\"language-text\">timeout</code>, <code class=\"language-text\">fast</code>, and <code class=\"language-text\">threads</code> options can be overridden on the command line when invoking the program as explained in <a href=\"#command-line-arguments\">Command-Line Arguments</a>.</p>\n<h3 id=\"threads\" style=\"position:relative;\"><a href=\"#threads\" aria-label=\"threads permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>threads</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    threads: &lt;integer>\n};</code></pre></div>\n<p>The number of threads to create to run reactions. This is required to be a non-negative integer. If this is not specified or a value 0 is given (the default), then a single thread is used, no thread library is included, and the <code class=\"language-text\">schedule()</code> function is not thread safe. Hence, unless you specify this, you cannot asynchronously schedule any actions. If the value given is 1 or more, then the specified number of worker threads will be created. On a multicore machine, these threads will typically be able to execute reactions in parallel if the program dependencies allow it. If a program contains physical actions, then a value of 1 or more will be forced; i.e., a threaded runtime will be used even if only one worker thread is created because the physical action needs the threading infrastructure to be able to safely asynchronous schedule events.</p>\n<p>For example, the following</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    threads: 4\n};</code></pre></div>\n<p>requests that the generated code create four threads, a good choice for a four-core machine.</p>\n<p><strong>Important:</strong> If the <code class=\"language-text\">threads</code> option is not given, then the generated C code makes no use of a thread library. In that case, everything runs in a single thread, and asynchronous calls to <code class=\"language-text\">schedule()</code> are not supported (the <code class=\"language-text\">schedule()</code> function will not be thread safe). If the <code class=\"language-text\">threads</code> option is given, even if you request only one thread, then thread-safe code is generated and <code class=\"language-text\">schedule()</code> may be called from any thread or even from an interrupt service routine.</p>\n<h3 id=\"cmake\" style=\"position:relative;\"><a href=\"#cmake\" aria-label=\"cmake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cmake</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    cmake: &lt;true or false>\n};</code></pre></div>\n<p>Enable or disable the CMake-based build system (the default is <code class=\"language-text\">true</code>). Enabling the CMake build system will result in a <code class=\"language-text\">CMakeLists.txt</code> being generated in the <code class=\"language-text\">src-gen</code> directory. This <code class=\"language-text\">CMakeLists.txt</code> is then used when <code class=\"language-text\">cmake</code> is invoked by the LF runtime (either the <code class=\"language-text\">lfc</code> or the IDE). Alternatively, the generated program can be built manually. To do so, in the <code class=\"language-text\">src-gen/ProgramName</code> directory, run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mkdir build &amp;&amp; cd build\ncmake ../\nmake</code></pre></div>\n<p>If <code class=\"language-text\">cmake</code> is disabled, <code class=\"language-text\">gcc</code> is directly invoked after code generation by default. In this case, additional target properties can be used to gain finer control over the compilation process. For example, in a source file named <code class=\"language-text\">Bar.lf</code>, you might specify:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    cmake: false,\n    compiler: \"cc\",\n    flags: \"-g -I/usr/local/include -L/usr/local/lib -lpaho-mqtt3c\"\n};</code></pre></div>\n<p>The <code class=\"language-text\">compiler</code> option here specifies to use <code class=\"language-text\">cc</code> rather than <code class=\"language-text\">gcc</code>.</p>\n<p>The <code class=\"language-text\">flags</code> option specifies to include debug information in the compiled code (<code class=\"language-text\">-g</code>); a directory to search for include files (<code class=\"language-text\">-I/usr/local/include</code>); a directory to search for library files (<code class=\"language-text\">-L/usr/local/lib</code>); a library to link with (<code class=\"language-text\">-lpaho-mqtt3c</code>, which will link with file <code class=\"language-text\">libpaho-mqtt3c.so</code>).</p>\n<p><strong>Note</strong>: Using the <code class=\"language-text\">flags</code> standard parameter when <code class=\"language-text\">cmake</code> is enabled is strongly discouraged, although supported. Flags are compiler-specific, and thus interfere with CMake’s ability to find the most suitable compiler for each platform. In a similar fashion, we recommend against the use of the <code class=\"language-text\">compiler</code> standard parameter for the same reason. A better solution is to provide a <code class=\"language-text\">cmake-include</code> file, as described next.</p>\n<h3 id=\"cmake-include\" style=\"position:relative;\"><a href=\"#cmake-include\" aria-label=\"cmake include permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cmake-include</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    cmake-include: [\"relative/path/to/foo.txt\", \"relative/path/to/bar.txt\", ...]\n};</code></pre></div>\n<p>Optionally append additional custom CMake instructions to the generated <code class=\"language-text\">CMakeLists.txt</code> from text files (e.g, <code class=\"language-text\">foo.txt</code>). The specified files are resolved using the file search algorithm documented [[here | Target-Specification#files]], and copied to the directory that contains the generated sources (only in the C target). This is done to make the generated code more portable (a feature that is useful in [[federated execution | Distributed-Execution]]).</p>\n<p>This target property can be used, for example, to add dependencies for various packages (e.g., by using <a href=\"https://cmake.org/cmake/help/latest/command/find_package.html\"><code class=\"language-text\">find_package()</code></a> and <a href=\"https://cmake.org/cmake/help/latest/command/target_link_libraries.html\"><code class=\"language-text\">target_link_libraries</code></a> commands). <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/CMakeInclude.lf\">CMakeInclude.lf</a> is an example that uses this feature. A more sophisticated example of the usage of this target parameter can be found in <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/src/Rhythm/Rhythm.lf\">Rhythm.lf</a>.</p>\n<p>A CMake variable called <code class=\"language-text\">${LF_MAIN_TARGET}</code> can be used in the included text file(s) for convenience. This variable will contain the name of the CMake target (i.e., the name of the main reactor). For example, a <code class=\"language-text\">foo.txt</code> file can contain:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">find_package(m REQUIRED) # Finds the m library\n\ntarget_link_libraries( ${LF_MAIN_TARGET} m ) # Links the m library</code></pre></div>\n<p><code class=\"language-text\">foo.txt</code> can then be included:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {\n    cmake-include: \"foo.txt\"\n};</code></pre></div>\n<p>In this case, “foo.txt” is in the same <code class=\"language-text\">src</code> folder as the main <code class=\"language-text\">.lf</code> file.</p>\n<p><strong>Note</strong>: For a general tutorial on finding packages in CMake, see <a href=\"https://cmake.org/cmake/help/latest/command/find_package.html\">this</a> external documentation entry. For a list of CMake find modules, see <a href=\"https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find-modules\">this</a>.</p>\n<p>Finally, <code class=\"language-text\">cmake-include</code> works in conjunction with <a href=\"#imports\">import</a>. If any imported <code class=\"language-text\">.lf</code> file has <code class=\"language-text\">cmake-include</code> in its target property, it will be appended to the current list of <code class=\"language-text\">cmake-include</code>s. These files will be resolved relative to the imported <code class=\"language-text\">.lf</code> file using the [[files | Target-Specification#files]] search procedure and copied to the directory that contains the generated sources. This will help resolve dependencies in imported reactors automatically and make the code more portable. <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeInclude.lf\">DistributedCMakeInclude.lf</a> is a test that uses this feature.</p>\n<p><strong>Note</strong>: For [[federated execution | Distributed-Execution]], both <code class=\"language-text\">cmake-include</code> and <code class=\"language-text\">file</code> are kept separate for each federate as much as possible. This means that if one federate is imported, or uses an imported reactor that other federates don’t use, it will only have access to <code class=\"language-text\">cmake-include</code>s and <code class=\"language-text\">file</code>s defined in the main <code class=\"language-text\">.lf</code> file, plus the selectively imported <code class=\"language-text\">.lf</code> files. <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeIncludeSeparateCompile.lf\">DistributedCMakeIncludeSeparateCompile.lf</a> is a test that demonstrates this feature.</p>\n<h2 id=\"command-line-arguments\" style=\"position:relative;\"><a href=\"#command-line-arguments\" aria-label=\"command line arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Command-Line Arguments</h2>\n<p>The generated C program understands the following command-line arguments, each of which has a short form (one character) and a long form:</p>\n<ul>\n<li><code class=\"language-text\">-f, --fast [true | false]</code>: Specifies whether to wait for physical time to match logical time. The default is <code class=\"language-text\">false</code>. If this is <code class=\"language-text\">true</code>, then the program will execute as fast as possible, letting logical time advance faster than physical time.</li>\n<li><code class=\"language-text\">-o, --timeout &lt;duration> &lt;units></code>: Stop execution when logical time has advanced by the specified <em>duration</em>. The units can be any of nsec, usec, msec, sec, minute, hour, day, week, or the plurals of those.</li>\n<li><code class=\"language-text\">-k, --keepalive [true | false]</code>: Specifies whether to stop execution if there are no events to process. This defaults to <code class=\"language-text\">false</code>, meaning that the program will stop executing when there are no more events on the event queue. If you set this to <code class=\"language-text\">true</code>, then the program will keep executing until either the <code class=\"language-text\">timeout</code> logical time is reached or the program is externally killed. If you have <code class=\"language-text\">physical action</code>s, it usually makes sense to set this to <code class=\"language-text\">true</code>.</li>\n<li><code class=\"language-text\">-t, --threads &lt;n></code>: Executed in <n> threads if possible. This option is ignored in the single-threaded version. That is, it is ignored if a <code class=\"language-text\">threads</code> option was not given in the source .lf file.</li>\n</ul>\n<p>Any other command-line arguments result in printing the above information.</p>\n<h2 id=\"imports\" style=\"position:relative;\"><a href=\"#imports\" aria-label=\"imports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Imports</h2>\n<p>The <a href=\"Language-Specification#import-statement\">import statement</a> can be used to share reactor definitions across several applications. Suppose for example that we modify the above Minimal.lf program as follows and store this in a file called <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/HelloWorld.lf\">HelloWorld.lf</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor HelloWorld {\n    reaction(startup) {=\n        printf(\"Hello World.\\n\");\n    =}\n}\nmain reactor HelloWorldTest {\n    a = new HelloWorld();\n}</code></pre></div>\n<p>This can be compiled and run, and its behavior will be identical to the version above.\nBut now, this can be imported into another reactor definition as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nimport HelloWorld.lf;\nmain reactor TwoHelloWorlds {\n    a = new HelloWorld();\n    b = new HelloWorld();\n}</code></pre></div>\n<p>This will create two instances of the HelloWorld reactor, and when executed, will print “Hello World” twice.</p>\n<p>Note that in the above example, the order in which the two reactions are invoked is undefined\nbecause there is no causal relationship between them. In fact, if you modify the target specification to say:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C {threads: 2};</code></pre></div>\n<p>then you might see garbled output if the implementation of <code class=\"language-text\">printf</code> on your machine is not thread safe (most modern implementations <em>are</em> thread safe, so you are not likely to see this behavior).</p>\n<p>A more interesting illustration of imports can be found in the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Import.lf\">Import.lf</a> test case in the <a href=\"https://github.com/lf-lang/lingua-franca/tree/master/test/C\">test directory</a>.</p>\n<h2 id=\"preamble\" style=\"position:relative;\"><a href=\"#preamble\" aria-label=\"preamble permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Preamble</h2>\n<p>Reactions may contain arbitrary C code, but often it is convenient for that code to invoke external libraries or to share procedure definitions. For either purpose, a reactor may include a <strong>preamble</strong> section. For example, the following reactor uses the common <code class=\"language-text\">stdlib</code> C library to convert a string to an integer:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor Preamble {\n    preamble {=\n        #include &lt;stdlib.h>\n    =}\n    timer t;\n    reaction(t) {=\n        char* s = \"42\";\n        int i = atoi(s);\n        printf(\"Converted string %s to int %d.\\n\", s, i);\n    =}\n}</code></pre></div>\n<p>This will print:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Converted string 42 to int 42.</code></pre></div>\n<p>By putting the <code class=\"language-text\">#include</code> in the <strong>preamble</strong>, the library becomes available in all reactions of this reactor. Oddly, it also becomes available in all subsequently defined reactors in the same file or in files that include this file.</p>\n<p>You can also use the preamble to define functions that are shared across reactions and reactors (this is <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Preamble.lf\">Preamble.lf</a> in the test suite):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor Preamble {\n    preamble {=\n        int add_42(int i) {\n            return i + 42;\n        }\n    =}\n    timer t;\n    reaction(t) {=\n        printf(\"42 plus 42 is %d.\\n\", add_42(42));\n    =}\n}</code></pre></div>\n<p>Not surprisingly, this will print:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">42 plus 42 is 84.</code></pre></div>\n<h3 id=\"using-state-variables\" style=\"position:relative;\"><a href=\"#using-state-variables\" aria-label=\"using state variables permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using State Variables</h3>\n<p>A reactor may declare state variables, which become properties of each instance of the reactor. For example, the following reactor (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/lib/src/Count.lf\">Count.lf</a> and <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Count.lf\">CountTest.lf</a>) will produce the output sequence 1, 2, 3, … :</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Count {\n    state count:int(1);\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, self->count++);\n    =}\n}</code></pre></div>\n<p>The declaration on the second line gives the variable the name “count”, declares its type to be <code class=\"language-text\">int</code>, and initializes its value to 1. The type and initial value can be enclosed in the C-code delimiters <code class=\"language-text\">{= ... =}</code> if they are not simple identifiers, but in this case, that is not necessary.</p>\n<p><strong>NOTE</strong>: String types in C are <code class=\"language-text\">char*</code>. But, as explained below, types ending with <code class=\"language-text\">*</code> are interpreted specially to provide automatic memory management, which we generally don’t want with strings (a string that is a compile-time constant must not be freed). You could enclose the type as <code class=\"language-text\">{= char* =}</code>, but to avoid this awkwardness, the header files include a typedef that permits using <code class=\"language-text\">string</code> instead of <code class=\"language-text\">char*</code>. For an example using <code class=\"language-text\">string</code> data types, see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayString.lf\">DelayString.lf</a>.</p>\n<p>In the body of the reaction, the state variable is referenced using the syntax <code class=\"language-text\">self->count</code>. Here, <strong>self</strong> is a keyword that is provided by Lingua Franca. It refers to a struct that contains all the instance-specific data associated with an instance of the reactor. Since each instance of a reactor has its own state variables, these variables are carried in the <strong>self</strong> struct.</p>\n<p>It may be tempting to declare state variables in the <strong>preamble</strong>, as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor FlawedCount {\n    preamble {=\n        int count = 0;\n    =}\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, count++);\n    =}\n}</code></pre></div>\n<p>This will produce a sequence of integers, but if there is more than one instance of the reactor, those instances will share the same variable count. Hence, <strong>don’t do this</strong>! Sharing variables across instances of reactors violates a basic principle, which is that reactors communicate only by sending messages to one another. Sharing variables will make your program nondeterministic. If you have multiple instances of the above FlawedCount reactor, the outputs produced by each instance will not be predictable, and in a multithreaded implementation, will also not be repeatable.</p>\n<p>A state variable may be a time value, declared as follows (see for example <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SlowingClock.lf\">SlowingClock.lf</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    state time_value:time(100 msec);</code></pre></div>\n<p>The <code class=\"language-text\">self->time_value</code> variable will be of type <code class=\"language-text\">instant_t</code>, which is a <code class=\"language-text\">long long</code> and the same type as <code class=\"language-text\">interval_t</code>. The value of the variable is a number in units of nanoseconds.</p>\n<p>A state variable can have an array value. For example, the [MovingAverage] (<a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/MovingAverage.lf\">https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/MovingAverage.lf</a>) reactor computes the <strong>moving average</strong> of the last four inputs each time it receives an input:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor MovingAverageImpl {\n    state delay_line:double[](0.0, 0.0, 0.0);\n    state index:int(0);\n    input in:double;\n    output out:double;\n    reaction(in) -> out {=\n        // Calculate the output.\n        double sum = in->value;\n        for (int i = 0; i &lt; 3; i++) {\n            sum += self->delay_line[i];\n        }\n        SET(out, sum/4.0);\n\n        // Insert the input in the delay line.\n        self->delay_line[self->index] = in->value;\n\n        // Update the index for the next input.\n        self->index++;\n        if (self->index >= 3) {\n            self->index = 0;\n        }\n    =}\n}</code></pre></div>\n<p>The second line declares that the type of the state variable is an array of <code class=\"language-text\">double</code>s with the initial value of the array being a three-element array filled with zeros.</p>\n<p>States whose type are structs can similarly be initialized. See <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsState.lf\">StructAsState.lf</a>.</p>\n<h3 id=\"using-parameters\" style=\"position:relative;\"><a href=\"#using-parameters\" aria-label=\"using parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Parameters</h3>\n<p>Reactor parameters are also referenced in the C code using the <strong>self</strong> struct. The <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Stride.lf\">Stride</a> example modifies the above <code class=\"language-text\">Count</code> reactor so that its stride is a parameter:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor Count(stride:int(1)) {\n    state count:int(1);\n    output y:int;\n    timer t(0, 100 msec);\n    reaction(t) -> y {=\n        SET(y, self->count);\n        self->count += self->stride;\n    =}\n}\nreactor Display {\n    input x:int;\n    reaction(x) {=\n        printf(\"Received: %d.\\n\", x->value);\n    =}\n}\nmain reactor Stride {\n    c = new Count(stride = 2);\n    d = new Display();\n    c.y -> d.x;\n}</code></pre></div>\n<p>The second line defines the <code class=\"language-text\">stride</code> parameter, gives its type, and gives its initial value. As with state variables, the type and initial value can be enclosed in <code class=\"language-text\">{= ... =}</code> if necessary. The parameter is referenced in the reaction with the syntax <code class=\"language-text\">self->stride</code>.</p>\n<p>When the reactor is instantiated, the default parameter value can be overridden. This is done in the above example near the bottom with the line:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    c = new Count(stride = 2);</code></pre></div>\n<p>If there is more than one parameter, use a comma separated list of assignments.</p>\n<p>Parameters can have array values, though some care is needed. The <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsParameter.lf\">ArrayAsParameter</a> example outputs the elements of an array as a sequence of individual messages:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source(sequence:int[](0, 1, 2), n_sequence:int(3)) {\n    output out:int;\n    state count:int(0);\n    logical action next;\n    reaction(startup, next) -> out, next {=\n        SET(out, self->sequence[self->count]);\n        self->count++;\n        if (self->count &lt; self->n_sequence) {\n            schedule(next, 0);\n        }\n    =}\n}</code></pre></div>\n<p>The <strong>logical action</strong> named <code class=\"language-text\">next</code> and the <code class=\"language-text\">schedule</code> function are explained below in <a href=\"#Scheduling-Delayed-Reactions\">Scheduling Delayed Reactions</a>; here they are used simply to repeat the reaction until all elements of the array have been sent.</p>\n<p>In C, arrays do not encode their own length, so a separate parameter is used for the array length. Obviously, there is potential here for errors, where the array length doesn’t match the length parameter.</p>\n<p>Above, the parameter default value is an array with three elements, <code class=\"language-text\">[0, 1, 2]</code>. The syntax for giving this default value is that of a Lingua Franca list, <code class=\"language-text\">(0, 1, 2)</code>, which gets converted by the code generator into a C static initializer. The default value can be overridden when instantiating the reactor using a similar syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    s = new Source(sequence = (1, 2, 3, 4), n_sequence=4);</code></pre></div>\n<h3 id=\"sending-and-receiving-arrays-and-structs\" style=\"position:relative;\"><a href=\"#sending-and-receiving-arrays-and-structs\" aria-label=\"sending and receiving arrays and structs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sending and Receiving Arrays and Structs</h3>\n<p>You can define your own datatypes in C and send and receive those. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsType.lf\">StructAsType</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor StructAsType {\n    preamble {=\n        typedef struct hello_t {\n            char* name;\n            int value;\n        } hello_t;\n    =}\n    output out:hello_t;\n    reaction(startup) -> out {=\n        struct hello_t temp = {\"Earth\", 42};\n        SET(out, temp);\n    =}\n}</code></pre></div>\n<p>The <strong>preamble</strong> code defines a struct datatype. In the reaction to <strong>startup</strong>, the reactor creates an instance of this struct on the stack (as a local variable named <code class=\"language-text\">temp</code>) and then copies that struct to the output using the <code class=\"language-text\">SET</code> macro.</p>\n<p>For large structs, it may be inefficient to create a struct on the stack and copy it to the output, as done above. You can instead write directly to the fields of the struct. For example, the above reaction could be rewritten as follows (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructAsTypeDirect.lf\">StructAsTypeDirect</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(startup) -> out {=\n        out->value.name = \"Earth\";\n        out->value.value = 42;\n        SET_PRESENT(out);\n    =}</code></pre></div>\n<p>The final call to <code class=\"language-text\">SET_PRESENT</code> is necessary to inform downstream reactors that the struct has a new value. (This is a macro that simply does <code class=\"language-text\">out->is_present = true</code>). Note that in subsequent reactions, the values of the struct persist. Hence, this technique can be very efficient if a large struct is modified only slightly in each of a sequence of reactions.</p>\n<p>A reactor receiving the struct message uses the struct as normal in C:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:hello_t;\n    reaction(in) {=\n        printf(\"Received: name = %s, value = %d\\n\", in->value.name, in->value.value);\n    =}\n}</code></pre></div>\n<p>The preamble should not be repeated in this reactor definition if the two reactors are defined together because this will trigger an error when the compiler thinks that hello_t is being redefined.</p>\n<p>Arrays that have fixed sizes are handled similarly. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsType.lf\">ArrayAsType</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayAsType {\n    output out:int[3];\n    reaction(startup) -> out {=\n        out[0] = 0;\n        out[1] = 1;\n        out[2] = 2;\n        SET_PRESENT(out);\n    =}\n}</code></pre></div>\n<p>Here, the output is declared to have type <code class=\"language-text\">int[3]</code>, an array of three integers. The startup reaction above writes to the array and then calls <code class=\"language-text\">SET_PRESENT</code> to indicate an updated value. Again, the values in the array will persist across reactions.</p>\n<p>A reactor receiving this array is straightforward. It just references the array elements as usual in C, as illustrated by this example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:int[3];\n    reaction(in) {=\n        printf(\"Received: [\");\n        for (int i = 0; i &lt; 3; i++) {\n            if (i > 0) printf(\", \");\n            printf(\"%d\", in->value[i]);\n        }\n        printf(\"]\\n\");\n    =}\n}</code></pre></div>\n<h4 id=\"dynamically-allocated-arrays\" style=\"position:relative;\"><a href=\"#dynamically-allocated-arrays\" aria-label=\"dynamically allocated arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamically Allocated Arrays</h4>\n<p>For arrays where the size is variable, it may be necessary to dynamically allocate memory. But when should that memory be freed? A reactor cannot know when downstream reactors are done with the data. Lingua Franca provides utilities for managing this using reference counting. You can pass a pointer to a dynamically allocated object as illustrated in the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayPrint.lf\">ArrayPrint</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayPrint {\n    output out:int[];\n    reaction(startup) -> out {=\n        // Dynamically allocate an output array of length 3.\n        SET_NEW_ARRAY(out, 3);\n        // Above allocates the array, which then must be populated.\n        out[0] = 0;\n        out[1] = 1;\n        out[2] = 2;\n    =}\n}</code></pre></div>\n<p>This declares the output datatype to be <code class=\"language-text\">int[]</code> (or, equivalently, <code class=\"language-text\">int*</code>), an array of integers of unspecified size. To produce the array in a reaction, it uses the library function <code class=\"language-text\">SET_NEW_ARRAY</code> to allocate an array of length 3 and sets the output to send that array. The reaction then populates the array with data. The deallocation of the memory for the array will occur automatically after the last reactor that receives a pointer to the array has finished using it.</p>\n<p>A reactor receiving the array looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print {\n    input in:int[];\n    reaction(in) {=\n        printf(\"Received: [\");\n        for (int i = 0; i &lt; in->length; i++) {\n            if (i > 0) printf(\", \");\n            printf(\"%d\", in->value[i]);\n        }\n        printf(\"]\\n\");\n    =}\n}</code></pre></div>\n<p>In the body of the reaction, <code class=\"language-text\">in->value</code> is a pointer to first element of the array, so it can be indexed as usual with arrays in C, <code class=\"language-text\">in->value[i]</code>. Moreover, a variable <code class=\"language-text\">in->length</code> is bound to the length of the array.</p>\n<p>Although it cannot be enforced in C, the receiving reactor should not modify the values stored in the array. Inputs are logically <em>immutable</em> because there may be several recipients. Any recipient that wishes to modify the array should make a copy of it. Fortunately, a utility is provided for this pattern. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayScale.lf\">ArrayScale</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor ArrayScale(scale:int(2)) {\n    mutable input in:int[];\n    output out:int[];\n    reaction(in) -> out {=\n        for(int i = 0; i &lt; in->length; i++) {\n            in->value[i] *= self->scale;\n        }\n        SET_TOKEN(out, in->token);\n    =}\n}</code></pre></div>\n<p>Here, the input is declared <strong>mutable</strong>, which means that any reaction is free to modify the input. If this reactor is the only recipient of the array or the last recipient of the array, then this will not copy of the array but rather use the original array. Otherwise, it will use a copy.</p>\n<p>The above <code class=\"language-text\">ArrayScale</code> reactor modifies the array and then forwards it to its output port using the <code class=\"language-text\">SET_TOKEN()</code> macro. That macro further delegates to downstream reactors the responsibility for freeing dynamically allocated memory once all readers have completed their work.</p>\n<p>If the above code were not to forward the array, then the dynamically allocated memory will be automatically freed when this reactor is done with it.</p>\n<p>The above three reactors can be combined into a pipeline as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor ArrayScaleTest {\n    s = new ArrayPrint();\n    c = new ArrayScale();\n    p = new Print();\n    s.out -> c.in;\n    c.out -> p.in;\n}</code></pre></div>\n<p>In this composite, the array is allocated by <code class=\"language-text\">ArrayPrint</code>, modified by <code class=\"language-text\">ArrayScale</code>, and deallocated (freed) after <code class=\"language-text\">Print</code> has reacted. No copy is necessary because <code class=\"language-text\">ArrayScale</code> is the only recipient of the original array.</p>\n<p>Inputs and outputs can also be dynamically allocated structs. In fact, Lingua Franca’s C target will treat any input or output datatype that ends with <code class=\"language-text\">[]</code> or <code class=\"language-text\">*</code> specially by providing utilities for allocating memory and modifying and forwarding. Deallocation of the allocated memory is automatic. The complete set of utilities is given below.</p>\n<h4 id=\"macros-for-setting-output-values\" style=\"position:relative;\"><a href=\"#macros-for-setting-output-values\" aria-label=\"macros for setting output values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Macros For Setting Output Values</h4>\n<p>In all of the following, <em>out</em> is the name of the output and <em>value</em> is the value to be sent.</p>\n<blockquote>\n<p><strong>SET</strong>(<em>out</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Set the specified output (or input of a contained reactor) to the specified value. This version is used for primitive type such as `int`, `double`, etc. as well as the built-in types `bool` and `string` (but only if the string is a statically allocated constant; otherwise, see `SET_NEW_ARRAY`). It can also be used for structs with a type defined by a `typedef` so that the type designating string does not end in '*'. The value is copied and therefore the variable carrying the value can be subsequently modified without changing the output.</code></pre></div>\n<blockquote>\n<p><strong>SET_ARRAY</strong>(<em>out</em>, <em>value</em>, <em>element_size</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `[]` or `*`, such as `int[]`. This version is for use when the *value* to be sent is in dynamically allocated memory that will need to be freed downstream. The allocated memory will be automatically freed when all recipients of the outputs are done with it. Since C does not encode array sizes as part of the array, the *length* and *element_size* must be given (the latter is the size of each element in bytes). See [SetArray.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SetArray.lf).</code></pre></div>\n<blockquote>\n<p><strong>SET_NEW</strong>(<em>out</em>);\nThis version is used for outputs with a type declaration ending with <code class=\"language-text\">*</code> (see example below). This sets the <code class=\"language-text\">out</code> variable to point to newly allocated memory for storing the specified output type. After calling this function, the reaction should populate that memory with the content it intends to send to downstream reactors. This macro is equivalent to <code class=\"language-text\">SET_NEW_ARRAY(out, 1)</code>. See <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/StructPrint.lf\">StructPrint.lf</a></p>\n</blockquote>\n<blockquote>\n<p><strong>SET_NEW_ARRAY</strong>(<em>out</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `[]` or `*`. This sets the *out* variable to point to newly allocated memory sufficient to hold an array of the specified length containing the output type in each element. The caller should subsequently populate the array with the contents that it intends to send to downstream reactors.  See [ArrayPrint.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayPrint.lf).\n**Dynamically allocated strings:** If an output is to be a dynamically allocated string, as opposed to a static string constant, then you can use `SET_NEW_ARRAY` to allocate the memory, and the memory will be automatically freed downstream after the all users have read the string. To do this, set the output type to `char[]` or `char*` rather than `string` and call `SET_NEW_ARRAY` with the desired length. After this, *out* will point to a char array of the required length. You can then populate it with your desired string, e.g. using `snprintf()`. See [DistributedToken.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/federated/DistributedToken.lf)</code></pre></div>\n<blockquote>\n<p><strong>SET_PRESENT</strong>(<em>out</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version just sets the *out*->is_present variable corresponding to the specified output  to true. This is normally used with array outputs with fixed sizes and statically allocated structs.  In these cases, the values in the output are normally written directly to the array or struct. See [ArrayAsType.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ArrayAsType.lf)</code></pre></div>\n<blockquote>\n<p><strong>SET_TOKEN</strong>(<em>out</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used for outputs with a type declaration ending with `*` (any pointer) or `[]` (any array). The *value* argument should be a struct of type `token_t`. This can be the trickiest form to use, but it is rarely necessary for the programmer to create their own (dynamically allocated) instance of `token_t`. Consider the [SetToken.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SetToken.lf) example:</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reactor Source {\n        output out:int*;\n        logical action a:int;\n        reaction(startup) -> a {=\n            schedule_int(a, MSEC(200), 42);\n        =}\n        reaction(a) -> out {=\n            SET_TOKEN(out, a->token);\n        =}\n    }</code></pre></div>\n<p>Here, the first reaction schedules an integer-valued action to trigger after 200 microseconds. As explained below, action payloads are carried by tokens. The second reaction grabs the token rather than the value using the syntax <code class=\"language-text\">a->token</code> (the name of the action followed by <code class=\"language-text\">->token</code>). It then forwards the token to the output. The output data type is <code class=\"language-text\">int*</code> not <code class=\"language-text\">int</code> because the token carries a pointer to dynamically allocated memory that contains the value. All inputs and outputs with types ending in <code class=\"language-text\">*</code> or <code class=\"language-text\">[]</code> are carried by tokens.</p>\n<p>All of the SET macros will overwrite any output value previously set at the same logical time and will cause the final output value to be sent to all reactors connected to the output. They also all set a local <em>out</em>->is_present variable to true. This can be used to subsequently test whether the output value has been set.</p>\n<h4 id=\"dynamically-allocated-structs\" style=\"position:relative;\"><a href=\"#dynamically-allocated-structs\" aria-label=\"dynamically allocated structs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamically Allocated Structs</h4>\n<p>The <code class=\"language-text\">SET_NEW</code> and <code class=\"language-text\">SET_TOKEN</code> macros can be used to send <code class=\"language-text\">structs</code> of arbitrary complexity. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor StructPrint {\n    preamble {=\n        typedef struct hello_t {\n            char* name;\n            int value;\n        } hello_t;\n    =}\n    output out:hello_t*;\n    reaction(startup) -> out {=\n        // Dynamically allocate an output struct.\n        SET_NEW(out);\n        // Above allocates a struct, which then must be populated.\n        out->value->name = \"Earth\";\n        out->value->value = 42;\n    =}\n}</code></pre></div>\n<p>The <strong>preamble</strong> declares a struct type <code class=\"language-text\">hello_t</code> with two fields, and the <code class=\"language-text\">SET_NEW</code> macro allocates memory to contain such a struct. The subsequent code populates that memory. A reactor receiving this struct might look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Print() {\n    input in:hello_t*;\n    reaction(in) {=\n        printf(\"Received: name = %s, value = %d\\n\",\n            in->value->name, in->value->value\n        );\n    =}\n}</code></pre></div>\n<p>Just as with arrays, an input with a pointer type can be declared <strong>mutable</strong>, in which case it is safe to modify the fields and forward the struct.</p>\n<p>Occasionally, you will want an input or output type to be a pointer, but you don’t want the automatic memory allocation and deallocation. A simple example is a string type, which in C is <code class=\"language-text\">char*</code>. Consider the following (erroneous) reactor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Erroneous {\n    output out:char*;\n    reaction(startup) -> out {=\n        SET(out, \"Hello World\");\n    =}\n}</code></pre></div>\n<p>An output data type that ends with <code class=\"language-text\">*</code> signals to Lingua Franca that the message is dynamically allocated and must be freed downstream after all recipients are done with it. But the “Hello World” string here is statically allocated, so an error will occur when the last downstream reactor to use this message attempts to free the allocated memory. To avoid this for strings, you can use the <code class=\"language-text\">string</code> type, defined in <code class=\"language-text\">reactor.h</code>, as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Fixed {\n    output out:string;\n    reaction(startup) -> out {=\n        SET(out, \"Hello World\");\n    =}\n}</code></pre></div>\n<p>The <code class=\"language-text\">string</code> type is equivalent to <code class=\"language-text\">char*</code>, but since it doesn’t end with <code class=\"language-text\">*</code>, it does not signal to Lingua Franca that the type is dynamically allocated. Lingua Franca only handles allocation and deallocation for types that are specified literally with a final <code class=\"language-text\">*</code> in the type name. The same trick can be used for any type where you don’t want automatic allocation and deallocation. E.g., the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/SendsPointerTest.lf\">SendsPointer</a> example looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor SendsPointer  {\n    preamble {=\n        typedef int* int_pointer;\n    =}\n    output out:int_pointer;\n    reaction(startup) -> out {=\n        static int my_constant = 42;\n        SET(out, &amp;my_constant;)\n    =}\n}</code></pre></div>\n<p>The above technique can be used to abuse the reactor model of computation by communicating pointers to shared variables. This is generally a bad idea unless those shared variables are immutable. The result will likely be nondeterministic. Also, communicating pointers across machines that do not share memory will not work at all.</p>\n<h2 id=\"timed-behavior\" style=\"position:relative;\"><a href=\"#timed-behavior\" aria-label=\"timed behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Timed Behavior</h2>\n<p>Timers are specified exactly as in the <a href=\"Language-Specification#timer-declaration\">Lingua Franca language specification</a>. When working with time in the C code body of a reaction, however, you will need to know a bit about its internal representation.</p>\n<p>In the C target, the value of a time instant or interval is an integer specifying a number of nanoseconds. An instant is the number of nanoseconds that have elapsed since January 1, 1970. An interval is the difference between two instants. When an LF program starts executing, logical time is (normally) set to the instant provided by the operating system. (On some embedded platforms without real-time clocks, it will be set instead to zero.)</p>\n<p>Time in the C target is a <code class=\"language-text\">long long</code>, which is (normally) a 64 bit signed number. Since a 64-bit number has a limited range, this measure of time instants will overflow in approximately the year 2262. For better code clarity, two types are defined in <a href=\"https://github.com/lf-lang/reactor-c/blob/main/core/tag.h\">tag.h</a>, <code class=\"language-text\">instant_t</code> and <code class=\"language-text\">interval_t</code>, which you can use for time instants and intervals respectively. These are both equivalent to <code class=\"language-text\">long long</code>, but using those types will insulate your code against changes and platform-specific customizations.</p>\n<p>Lingua Franca uses a superdense model of time. A reaction is invoked at a logical <strong>tag</strong>, a struct consists of a <code class=\"language-text\">time</code> value (an <code class=\"language-text\">instant_t</code>, which is a <code class=\"language-text\">long long</code>) and a <code class=\"language-text\">microstep</code> value (a <code class=\"language-text\">microstep_t</code>, which is an unsigned <code class=\"language-text\">int</code>). The tag is guaranteed to not increase during the execution of a reaction. Outputs produced by a reaction have the same tag as the inputs, actions, or timers that trigger the reaction, and hence are <strong>logically simultaneous</strong>.</p>\n<p>The time structs and functions for working with time are defined in <a href=\"https://github.com/lf-lang/reactor-c/blob/main/core/tag.h\">tag.h</a>. The most useful functions are:</p>\n<ul>\n<li><code class=\"language-text\">tag_t get_current_tag()</code>: Get the current tag at which this reaction has been invoked.</li>\n<li><code class=\"language-text\">instant_t get_logical_time()</code>: Get the current logical time (the first part of the current tag).</li>\n<li><code class=\"language-text\">microstep_t get_microstep() </code>: Get the current microstep (the second part of the current tag).</li>\n<li><code class=\"language-text\">interval_t get_elapsed_logical_time()</code>: Get the logical time elapsed since program start.</li>\n<li><code class=\"language-text\">int compare_tags(tag_t, tag_t)</code>: Compare two tags, returning -1, 0, or 1 for less than, equal, and greater than.</li>\n</ul>\n<p>There are also some useful functions for accessing physical time:</p>\n<ul>\n<li><code class=\"language-text\">instant_t get_physical_time()</code>: Get the current physical time.</li>\n<li><code class=\"language-text\">instant_t get_elapsed_physical_time()</code>: Get the physical time elapsed since program start.</li>\n<li><code class=\"language-text\">instant_t get_start_time()</code>: Get the starting physical and logical time.</li>\n</ul>\n<p>The last of these is both a physical and logical time because, at the start of execution, the starting logical time is set equal to the current physical time as measured by a local clock.</p>\n<p>A reaction can examine the current logical time (which is constant during the execution of the reaction). For example, consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/GetTime.lf\">GetTime</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t logical = get_logical_time();\n        printf(\"Logical time is %lld.\\n\", logical);\n    =}\n}</code></pre></div>\n<p>When executed, you will get something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:18:36 2019\nplus 353609000 nanoseconds.\nLogical time is 1570987116353609000.\nLogical time is 1570987117353609000.\nLogical time is 1570987118353609000.\n...</code></pre></div>\n<p>The first two lines give the current time-of-day provided by the execution platform at the start of execution. This is used to initialize logical time. Subsequent values of logical time are printed out in their raw form, rather than the friendlier form in the first two lines. If you look closely, you will see that each number is one second larger than the previous number, where one second is 1000000000 nanoseconds.</p>\n<p>You can also obtain the <em>elapsed</em> logical time since the start of execution:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        interval_t elapsed = get_elapsed_logical_time();\n        printf(\"Elapsed logical time is %lld.\\n\", elapsed);\n    =}\n}</code></pre></div>\n<p>This will produce:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:25:22 2019\nplus 833273000 nanoseconds.\nElapsed logical time is 0.\nElapsed logical time is 1000000000.\nElapsed logical time is 2000000000.\n...</code></pre></div>\n<p>You can also get physical time, which comes from your platform’s real-time clock:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t physical = get_physical_time();\n        printf(\"Physical time is %lld.\\n\", physical);\n    =}\n}</code></pre></div>\n<p>This will produce something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Sun Oct 13 10:35:59 2019\nplus 984992000 nanoseconds.\nPhysical time is 1570988159986108000.\nPhysical time is 1570988160990219000.\nPhysical time is 1570988161990067000.\n...</code></pre></div>\n<p>Finally, you can get elapsed physical time:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor GetTime {\n    timer t(0, 1 sec);\n    reaction(t) {=\n        instant_t elapsed_physical = get_elapsed_physical_time();\n        printf(\"Elapsed physical time is %lld.\\n\", elapsed_physical);\n    =}\n}</code></pre></div>\n<p>This will produce something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Elapsed physical time is 657000.\nElapsed physical time is 1001856000.\nElapsed physical time is 2004761000.\n...</code></pre></div>\n<p>Notice that these numbers are increasing by <em>roughly</em> one second each time. If you set the <code class=\"language-text\">fast</code> target parameter to <code class=\"language-text\">true</code>, then physical time will elapse much faster than logical time.</p>\n<p>Working with nanoseconds in C code can be tedious if you are interested in longer durations. For convenience, a set of macros are available to the C programmer to convert time units into the required nanoseconds. For example, you can specify 200 msec in C code as <code class=\"language-text\">MSEC(200)</code> or two weeks as <code class=\"language-text\">WEEKS(2)</code>. The provided macros are NSEC, USEC (for microseconds), MSEC, SEC, MINUTE, HOUR, DAY, and WEEK. You may also use the plural of any of these. Examples are given in the next section.</p>\n<h3 id=\"scheduling-delayed-reactions\" style=\"position:relative;\"><a href=\"#scheduling-delayed-reactions\" aria-label=\"scheduling delayed reactions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scheduling Delayed Reactions</h3>\n<p>The C target provides a variety of <code class=\"language-text\">schedule()</code> functions to trigger an action at a future logical time. Actions are described in the <a href=\"language-specification#action-declaration\">Language Specification</a> document. Consider the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/Schedule.lf\">Schedule</a> reactor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor Schedule {\n    input x:int;\n    logical action a;\n    reaction(a) {=\n        interval_t elapsed_time = get_elapsed_logical_time();\n        printf(\"Action triggered at logical time %lld nsec after start.\\n\", elapsed_time);\n    =}\n    reaction(x) -> a {=\n        schedule(a, MSEC(200));\n    =}\n}</code></pre></div>\n<p>When this reactor receives an input <code class=\"language-text\">x</code>, it calls <code class=\"language-text\">schedule()</code>, specifying the action <code class=\"language-text\">a</code> to be triggered and the logical time offset (200 msec). The action <code class=\"language-text\">a</code> will be triggered at a logical time 200 milliseconds after the arrival of input <code class=\"language-text\">x</code>. At that logical time, the second reaction will trigger and will use the <code class=\"language-text\">get_elapsed_logical_time()</code> function to determine how much logical time has elapsed since the start of execution.</p>\n<p>Notice that after the logical time offset of 200 msec, there may be another input <code class=\"language-text\">x</code> simultaneous with the action <code class=\"language-text\">a</code>. Because the reaction to <code class=\"language-text\">a</code> is given first, it will execute first. This becomes important when such a reactor is put into a feedback loop (see below).</p>\n<h3 id=\"zero-delay-actions\" style=\"position:relative;\"><a href=\"#zero-delay-actions\" aria-label=\"zero delay actions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Zero-Delay Actions</h3>\n<p>If the specified delay in a <code class=\"language-text\">schedule()</code> call is zero, then the action <code class=\"language-text\">a</code> will be triggered one <strong>microstep</strong> later in <strong>superdense time</strong> (see <a href=\"language-specification#superdense-time\">Superdense Time</a>). Hence, if the input <code class=\"language-text\">x</code> arrives at metric logical time <em>t</em>, and you call <code class=\"language-text\">schedule()</code> as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">schedule(a, 0);</code></pre></div>\n<p>then when a reaction to <code class=\"language-text\">a</code> is triggered, the input <code class=\"language-text\">x</code> will be absent (it was present at the <em>previous</em> microstep). The reaction to <code class=\"language-text\">x</code> and the reaction to <code class=\"language-text\">a</code> occur at the same metric time <em>t</em>, but separated by one microstep, so these two reactions are <em>not</em> logically simultaneous.</p>\n<p>The metric time is visible to the C programmer and can be obtained in a reaction using either\n<code class=\"language-text\">get_elapsed_logical_time()</code>, as above, or <code class=\"language-text\">get_logical_time()</code>. The latter function also returns a <code class=\"language-text\">long long</code> (aka <code class=\"language-text\">instant_t</code>), but its meaning is now the time elapsed since January 1, 1970 in nanoseconds.</p>\n<p>As described in the <a href=\"language-specification#action-declaration\">Language Specification</a> document, action declarations can have a <em>min_delay</em> parameter. This modifies the timestamp further. Also, the action declaration may be <strong>physical</strong> rather than <strong>logical</strong>, in which case, the assigned timestamp will depend on the physical clock of the executing platform.</p>\n<h2 id=\"actions-with-values\" style=\"position:relative;\"><a href=\"#actions-with-values\" aria-label=\"actions with values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Actions With Values</h2>\n<p>If an action is declared with a data type, then it can carry a <strong>value</strong>, a data value that becomes available to any reaction triggered by the action. This is particularly useful for physical actions that are externally triggered because it enables the action to convey information to the reactor. This could be, for example, the body of an incoming network message or a numerical reading from a sensor.</p>\n<p>Recall from the <a href=\"language-specification#Contained-Reactors\">Contained Reactors</a> section in the Language Specification document that the <strong>after</strong> keyword on a connection between ports introduces a logical delay. This is actually implemented using a logical action. We illustrate how this is done using the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayInt.lf\">DelayInt</a> example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayInt(delay:time(100 msec)) {\n    input in:int;\n    output out:int;\n    logical action d:int;\n    reaction(d) -> out {=\n        SET(out, d->value);\n    =}\n    reaction(in) -> d {=\n        schedule_int(d, self->delay, in->value);\n    =}\n}</code></pre></div>\n<p>Using this reactor as follows</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    d = new Delay();\n    source.out -> d.in;\n    d.in -> sink.out</code></pre></div>\n<p>is equivalent to</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    source.out -> sink.in after 100 msec</code></pre></div>\n<p>(except that our <code class=\"language-text\">DelayInt</code> reactor will only work with data type <code class=\"language-text\">int</code>).</p>\n<p>The action <code class=\"language-text\">d</code> is specified with a type <code class=\"language-text\">int</code>. The reaction to the input <code class=\"language-text\">in</code> declares as its effect the action <code class=\"language-text\">d</code>. This declaration makes it possible for the reaction to schedule a future triggering of <code class=\"language-text\">d</code>. The reaction uses one of several variants of the <strong>schedule</strong> function, namely <strong>schedule_int</strong>, a convenience function provided because integer payloads on actions are very common. We will see below, however, that payloads can have any data type.</p>\n<p>The first reaction declares that it is triggered by <code class=\"language-text\">d</code> and has effect <code class=\"language-text\">out</code>. To read the value, it uses the <code class=\"language-text\">d->value</code> variable. Because this reaction is first, the <code class=\"language-text\">out</code> at any logical time can be produced before the input <code class=\"language-text\">in</code> is even known to be present. Hence, this reactor can be used in a feedback loop, where <code class=\"language-text\">out</code> triggers a downstream reactor to send a message back to <code class=\"language-text\">in</code> of this same reactor. If the reactions were given in the opposite order, there would be causality loop and compilation would fail.</p>\n<p>If you are not sure whether an action carries a value, you can test for it as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    reaction(d) -> out {=\n        if (d->has_value) {\n            SET(out, d->value);\n        }\n    =}</code></pre></div>\n<p>It is possible to both be triggered by and schedule an action the same reaction. For example, this <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/CountSelf.lf\">CountSelf</a> reactor will produce a counting sequence after it is triggered the first time:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor CountSelf(delay:time(100 msec)) {\n    output out:int;\n    logical action a:int;\n    reaction(startup) -> a, out {=\n        SET(out, 0);\n        schedule_int(a, self->delay, 1);\n    =}\n    reaction(a) -> a, out {=\n        SET(out, a->value);\n        schedule_int(a, self->delay, a->value + 1);\n    =}\n}</code></pre></div>\n<p>Of course, to produce a counting sequence, it would be more efficient to use a state variable.</p>\n<p>Actions with values can be rather tricky to use because the value must usually be carried in dynamically allocated memory. It will not work for value to refer to a state variable of the reactor because that state variable will likely have changed value by the time the reactions to the action are invoked. Several variants of the <strong>schedule</strong> function are provided to make it easier to pass values across time in varying circumstances.</p>\n<blockquote>\n<p><strong>schedule</strong>(<em>action</em>, <em>offset</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This is the simplest version as it carries no value. The action need not have a data type.</code></pre></div>\n<blockquote>\n<p><strong>schedule_int</strong>(<em>action</em>, <em>offset</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version carries an `int` value. The datatype of the action is required to be `int`.</code></pre></div>\n<blockquote>\n<p><strong>schedule_token</strong>(<em>action</em>, <em>offset</em>, <em>value</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version carries a **token**, which has type `token_t` and points to the value, which can have any type. There is a `create_token()` function that can be used to create a token, but programmers will rarely need to use this.  Instead, you can use `schedule_value()` (see below), which will automatically create a token. Alternatively, for inputs with types ending in `*` or `[]`, the value is wrapped in a token, and the token can be obtained using the syntax `inputname->token` in a reaction and then forwarded using `schedule_token()` (see section [Dynamically Allocated Structs](#Dynamically-Allocated-Structs) above). If the input is mutable, the reaction can then even modify the value pointed to by the token and/or use `schedule_token()` to send the token to a future logical time. For example, the [DelayPointer](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayPointer.lf) reactor realizes a logical delay for any datatype carried by a token:</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayPointer(delay:time(100 msec)) {\n    input in:void*;\n    output out:void*;\n    logical action a:void*;\n    reaction(a) -> out {=\n        // Using SET_TOKEN delegates responsibility for\n        // freeing the allocated memory downstream.\n        SET_TOKEN(out, a->token);\n    =}\n    reaction(in) -> a {=\n        // Schedule the actual token from the input rather than\n        // a new token with a copy of the input value.\n        schedule_token(a, self->delay, in->token);\n    =}\n}</code></pre></div>\n<blockquote>\n<p><strong>schedule_value</strong>(<em>action</em>, <em>offset</em>, <em>value</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is used to send into the future a value that has been dynamically allocated malloc. It will be automatically freed when it is no longer needed. The *value* argument is a pointer to the memory containing the value. The *length* argument should be 1 if it is a not an array and the array length otherwise. This length will be needed downstream to interpret the data correctly. See [ScheduleValue.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/ScheduleValue.lf).</code></pre></div>\n<blockquote>\n<p><strong>schedule_copy</strong>(<em>action</em>, <em>offset</em>, <em>value</em>, <em>length</em>);</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This version is for sending a copy of some data pointed to by the *value* argument. The data is assumed to be a scalar or array of type matching the *action* type. The *length* argument should be 1 if it is a not an array and the array length otherwise. This length will be needed downstream to interpret the data correctly.</code></pre></div>\n<p>Occasionally, an action payload may not be dynamically allocated nor freed. For example, it could be a pointer to a statically allocated string. If you know this to be the case, the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/DelayString.lf\">DelayString</a> reactor will realize a logical time delay on such a string:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor DelayString(delay:time(100 msec)) {\n    input in:string;\n    output out:string;\n    logical action a:string;\n    reaction(a) -> out {=\n        SET(out, a->value);\n    =}\n    reaction(in) -> a {=\n        // The following copies the char*, not the string.\n        schedule_copy(a, self->delay, &amp;(in->value), 1);\n    =}\n}</code></pre></div>\n<p>The datatype <code class=\"language-text\">string</code> is an alias for <code class=\"language-text\">char*</code>, but Lingua Franca does not know this, so it creates a token that contains a copy of the pointer to the string rather than a copy of the string itself.</p>\n<h2 id=\"stopping-execution\" style=\"position:relative;\"><a href=\"#stopping-execution\" aria-label=\"stopping execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stopping Execution</h2>\n<p>A reaction may request that the execution stop after all events with the current timestamp have been processed by calling the built-in function <code class=\"language-text\">request_stop()</code>, which takes no arguments. In a non-federated execution, the returned time is normally the same as the current logical time, and the actual last tag will be one microstep later. In a federated execution, however, the stop time will likely be larger than the current logical time. All federates are assured of stopping at the same logical time.</p>\n<h2 id=\"log-and-debug-information\" style=\"position:relative;\"><a href=\"#log-and-debug-information\" aria-label=\"log and debug information permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Log and Debug Information</h2>\n<p>A suite of useful functions is provided in <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/core/util.h\">util.h</a> for producing messages to be made visible when the generated program is run. Of course, you can always use <code class=\"language-text\">printf</code>, but this is not a good choice for logging or debug information, and it is not a good choice when output needs to be redirected to a window or some other user interface (see for example the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/org.lflang/src/lib/C/util/sensor_simulator.h\">sensor simulator</a>). Also, [[Distributed Execution]], these functions identify which federate is producing the message. The functions are listed below. The arguments for all of these are identical to <code class=\"language-text\">printf</code> with the exception that a trailing newline is automatically added and therefore need not be included in the format string.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">DEBUG_PRINT(format, ...)</code>: Use this for verbose messages that are only needed during debugging. Nothing is printed unless the <a href=\"Language-Specification#Target-Specification\">target</a> parameter <code class=\"language-text\">logging</code> is set to <code class=\"language-text\">debug</code>. This is a macro so that overhead is minimized when nothing is to be printed.</p>\n</li>\n<li>\n<p><code class=\"language-text\">LOG_PRINT(format, ...)</code>: Use this for messages that are useful logs of the execution. Nothing is printed unless the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">target parameter <code class=\"language-text\">logging</code></a> is set to <code class=\"language-text\">log</code> or <code class=\"language-text\">debug</code>. This is a macro so that overhead is minimized when nothing is to be printed.</p>\n</li>\n<li>\n<p><code class=\"language-text\">info_print(format, ...)</code>: Use this for messages that should normally be printed but may need to be redirected to a user interface such as a window or terminal (see <code class=\"language-text\">register_print_function</code> below). These messages can be suppressed by setting the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a> to <code class=\"language-text\">warn</code> or <code class=\"language-text\">error</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">warning_print(format, ...)</code>: Use this for warning messages. These messages can be suppressed by setting the <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a> to <code class=\"language-text\">error</code>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">error_print(format, ...)</code>: Use this for error messages. These messages are not suppressed by any <a href=\"https://github.com/lf-lang/lingua-franca/wiki/Target-Specification#logging\">logging target property</a>.</p>\n</li>\n<li>\n<p><code class=\"language-text\">error_print_and_exit(format, ...)</code>: Use this for catastrophic errors.</p>\n</li>\n</ul>\n<p>In addition, a utility function is provided to register a function to redirect printed outputs:</p>\n<ul>\n<li><code class=\"language-text\">register_print_function(function)</code>: Register a function that will be used instead of <code class=\"language-text\">printf</code> to print messages generated by any of the above functions. The function should accept the same arguments as <code class=\"language-text\">printf</code>.</li>\n</ul>\n<h2 id=\"implementation-details\" style=\"position:relative;\"><a href=\"#implementation-details\" aria-label=\"implementation details permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Implementation Details</h2>\n<h3 id=\"included-libraries\" style=\"position:relative;\"><a href=\"#included-libraries\" aria-label=\"included libraries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Included Libraries</h3>\n<p>The generated code includes the following standard C libraries, so there is no need for a reactor definition to explicitly include them if they are needed:</p>\n<ul>\n<li>stdio.h</li>\n<li>stdlib.h</li>\n<li>string.h</li>\n<li>time.h</li>\n<li>errno.h</li>\n</ul>\n<p>In addition, the multithreaded implementation uses</p>\n<ul>\n<li>pthread.h</li>\n</ul>\n<h3 id=\"single-threaded-implementation\" style=\"position:relative;\"><a href=\"#single-threaded-implementation\" aria-label=\"single threaded implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single Threaded Implementation</h3>\n<p>The runtime library for the single-threaded implementation is in the following files:</p>\n<ul>\n<li>reactor.c</li>\n<li>reactor_common.c (included in the above using #include)</li>\n<li>pqueue.c</li>\n</ul>\n<p>Three header files provide the interfaces:</p>\n<ul>\n<li>reactor.h</li>\n<li>ctarget.h</li>\n<li>pqueue.h</li>\n</ul>\n<p>The strategy is to have two queues of pending accessor invocations, one that is sorted by timestamp (the event queue) and one that is sorted by priority (the reaction queue). Execution proceeds as follows:</p>\n<ol>\n<li>\n<p>At initialization, an event for each timer is put on the event queue and logical time is initialized to the current time, represented as the number of nanoseconds elapsed since January 1, 1970.</p>\n</li>\n<li>\n<p>At each logical time, pull all events from event queue that have the same earliest time stamp, find the reactions that these events trigger, and put them on the reaction queue. If there are no events on the event queue, then exit the program (unless the <code class=\"language-text\">--keepalive true</code> command-line argument is given).</p>\n</li>\n<li>\n<p>Wait until physical time matches or exceeds that earliest timestamp (unless the <code class=\"language-text\">--fast true</code> command-line argument is given). Then advance logical time to match that earliest timestamp.</p>\n</li>\n<li>\n<p>Execute reactions in order of priority from the reaction queue. These reactions may produce outputs, which results in more events getting put on the reaction queue. Those reactions are assured of having lower priority than the reaction that is executing. If a reaction calls <code class=\"language-text\">schedule()</code>, an event will be put on the event queue, not the reaction queue.</p>\n</li>\n<li>\n<p>When the reaction queue is empty, go to 2.</p>\n</li>\n</ol>\n<h3 id=\"multithreaded-implementation\" style=\"position:relative;\"><a href=\"#multithreaded-implementation\" aria-label=\"multithreaded implementation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multithreaded Implementation</h3>\n<p>The runtime library for the multithreaded implementation is in the following files:</p>\n<ul>\n<li>reactor_threaded.c</li>\n<li>reactor_common.c (included in the above using #include)</li>\n<li>pqueue.c</li>\n</ul>\n<p>The same two header files provide the interfaces:</p>\n<ul>\n<li>reactor.h</li>\n<li>pqueue.h</li>\n</ul>\n<p>The default number of worker threads is given by the <code class=\"language-text\">threads</code> argument in the <a href=\"#The-C-Target\">target</a> statement.\nThis can be overridden with the <code class=\"language-text\">--threads</code> <a href=\"#command-line-arguments\">command-line argument</a>.</p>\n<p>Upon initialization, the main thread will create the specified number of worker threads.\nA good choice is for this number to match the number of available cores.\nExecution proceeds in a manner similar to the <a href=\"single-threaded-implementation\">single threaded implementation</a>\nexcept that the worker threads concurrently draw reactions from the reaction queue.\nThe execution algorithm ensures that no reaction executes until all reactions that it depends on that are also\non the reaction queue have executed at the current logical time.</p>\n<p>FIXME: Describe the algorithm exploiting parallelism.</p>\n<h2 id=\"reactors-on-patmos\" style=\"position:relative;\"><a href=\"#reactors-on-patmos\" aria-label=\"reactors on patmos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reactors on Patmos</h2>\n<p>Reactors can be executed on <a href=\"https://github.com/t-crest/patmos\">Patmos</a>, a bare-metal execution platform\nthat is optimized for time-predictable execution. Well written C programs can be analyzed for their\nworst-case execution time (WCET).</p>\n<h3 id=\"compiling-and-running-reactors\" style=\"position:relative;\"><a href=\"#compiling-and-running-reactors\" aria-label=\"compiling and running reactors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Compiling and Running Reactors</h3>\n<p>Patmos can run in an FPGA, but there are also two\nsimulators available:</p>\n<ol>\n<li><code class=\"language-text\">pasim</code> a software ISA simulator that is written in C++.</li>\n<li><code class=\"language-text\">patemu</code> a cycle-accurate hardware emulator generated from the hardware description.</li>\n</ol>\n<p>To execute reactions on Patmos, the <a href=\"https://github.com/t-crest/patmos\">Patmos toolchain</a> needs\nto be installed. The web page contains a quick start, detailed information including how to\nperform WCET analysis is available in the\n<a href=\"http://patmos.compute.dtu.dk/patmos_handbook.pdf\">Patmos Reference Handbook</a>.</p>\n<p>To execute the “hello world” reactor on Patmos use the LF compiler to generate the C code.\nCompile the reactor with the Patmos compiler (in <code class=\"language-text\">src-gen</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patmos-clang Minimal.c -o Minimal.elf</code></pre></div>\n<p>The reactor can be executed on the SW simulator with:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pasim Minimal.elf</code></pre></div>\n<p>As Patmos is a bare metal runtime that has no notion of calendar time, its start time\nis considered the epoch and the following output will be observed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Start execution at time Thu Jan  1 00:00:00 1970\nplus 640000 nanoseconds.\nHello World.\nElapsed logical time (in nsec): 0\nElapsed physical time (in nsec): 3970000</code></pre></div>\n<p>The reactor can also be executed on the hardware emulator of Patmos:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patemu Minimal.elf</code></pre></div>\n<p>This execution is considerably slower than the SW simulator, as the concrete hardware\nof Patmos is simulated cycle-accurate.</p>\n<h3 id=\"worst-case-execution-time-analysis\" style=\"position:relative;\"><a href=\"#worst-case-execution-time-analysis\" aria-label=\"worst case execution time analysis permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Worst-Case Execution Time Analysis</h3>\n<p>Following example is a code fragment from\n<a href=\"https://github.com/lf-lang/lingua-franca/blob/master/xtext/org.icyphy.linguafranca/src/test/C/src/Wcet.lf\">Wcet.lf</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Work {\n    input in1: int;\n    input in2: int;\n    output out:int;\n    reaction(in1, in2) -> out {=\n    \tint ret;\n    \tif (in1 > 10) {\n    \t\tret = in2 * in1;\n    \t} else {\n    \t\tret = in2 + in1;\n    \t}\n        SET(out, ret);\n    =}\n}</code></pre></div>\n<p>We want to perform WCET analysis of the single reaction of the Work reactor.\nThis reaction, depending on the input data, will either perform a multiplication,\nwhich is more expensive in Patmos, or an addition. The WCET analysis shall consider\nthe multiplication path as the worst-case path. To generate the information for\nWCET analysis by the compiler we have to compile the application as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">patmos-clang -O2 -mserialize=wcet.pml Wcet.c</code></pre></div>\n<p>We investigate the C source code <code class=\"language-text\">Wcet.c</code> and find that the reaction we\nare interested is named <code class=\"language-text\">reaction_function1</code>. Therefore, we invoke WCET analysis\nas follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">platin wcet -i wcet.pml -b a.out -e reaction_function1 --report</code></pre></div>\n<p>This results in following report:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">...\n[platin] INFO: Finished run WCET analysis (platin)          in 62 ms\n[platin] INFO: best WCET bound: 242 cycles\n---\n- analysis-entry: reaction_function1\n  source: platin\n  cycles: 242\n...</code></pre></div>\n<p>The analysis gives the WCET of 242 clock cycles for the reaction,\nwhich includes clock cycles for data cache misses.\nFurther details on the WCET analysis\ntool <code class=\"language-text\">platin</code> and e.g., how to annotate loop bounds can be found in the\n<a href=\"http://patmos.compute.dtu.dk/patmos_handbook.pdf\">Patmos Reference Handbook</a>.</p>\n<p>Note, that the WCET analysis of a reaction does only include the code of the\nreaction function, not the cache miss cost of calling the function from\nthe scheduler or the cache miss cost when returning to the scheduler.</p>\n<h2 id=\"the-ccpp-target\" style=\"position:relative;\"><a href=\"#the-ccpp-target\" aria-label=\"the ccpp target permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The CCpp Target</h2>\n<p>In some cases, it might be needed or desirable to mix C and C++ code, including in the body of reactions, or in included libraries and header files. The C target uses a C compiler by default, and will fail to compile mixed C/C++ language programs. As a remedy, we offer a <code class=\"language-text\">CCpp</code> target that uses the C runtime but employs a C++ compiler to compile your program. To use it, simply replace <code class=\"language-text\">target C</code> with <code class=\"language-text\">target CCpp</code>.</p>\n<p>Here is a minimal example of a program written in the <code class=\"language-text\">CCpp</code> target, taken from <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/HelloWorldCCPP.lf\">HelloWorldCCPP.lf</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target CCpp;\nreactor HelloWorld {\n    preamble {=\n        #include &lt;iostream> // Note that no C++ header will be included by default.\n    =}\n    reaction(startup) {=\n        std::cout &lt;&lt; \"Hello World.\" &lt;&lt; std::endl;\n    =}\n}\nmain reactor {\n    a = new HelloWorld();\n}</code></pre></div>\n<p><strong>Note:</strong> Unless some <a href=\"Support-Matrix\">feature</a> in the C target is needed, we recommend using the <a href=\"Writing-Reactors-in-Cpp\">Cpp target</a> that uses a runtime that is written natively in C++.</p>\n<p><strong>Note:</strong> A <code class=\"language-text\">.lf</code> file that uses the <code class=\"language-text\">CCpp</code> target cannot and should not be imported to an <code class=\"language-text\">.lf</code> file that uses the <code class=\"language-text\">C</code> target. Although these two targets use essentially the same runtime, such a scenario can cause unintended compiler errors.</p>","headings":[{"value":"The C Target Specification","depth":2},{"value":"threads","depth":3},{"value":"cmake","depth":3},{"value":"cmake-include","depth":3},{"value":"Command-Line Arguments","depth":2},{"value":"Imports","depth":2},{"value":"Preamble","depth":2},{"value":"Using State Variables","depth":3},{"value":"Using Parameters","depth":3},{"value":"Sending and Receiving Arrays and Structs","depth":3},{"value":"Dynamically Allocated Arrays","depth":4},{"value":"Macros For Setting Output Values","depth":4},{"value":"Dynamically Allocated Structs","depth":4},{"value":"Timed Behavior","depth":2},{"value":"Scheduling Delayed Reactions","depth":3},{"value":"Zero-Delay Actions","depth":3},{"value":"Actions With Values","depth":2},{"value":"Stopping Execution","depth":2},{"value":"Log and Debug Information","depth":2},{"value":"Implementation Details","depth":2},{"value":"Included Libraries","depth":3},{"value":"Single Threaded Implementation","depth":3},{"value":"Multithreaded Implementation","depth":3},{"value":"Reactors on Patmos","depth":2},{"value":"Compiling and Running Reactors","depth":3},{"value":"Worst-Case Execution Time Analysis","depth":3},{"value":"The CCpp Target","depth":2}],"frontmatter":{"permalink":"/docs/handbook/write-reactor-c","title":"Writing Reactors in C","oneline":"Writing Reactors in C.","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Future Proof Package/Import System","oneline":"A future proof package and import system","permalink":"/docs/handbook/proof-import"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Future Proof Package/Import System","oneline":"A future proof package and import system","permalink":"/docs/handbook/proof-import"}}}},"pageContext":{"slug":"/docs/handbook/write-reactor-c","repoPath":"/packages/documentation/copy/en/topics/Writing Reactors in C.md","lang":"en","modifiedTime":"2022-04-10T21:13:36.813Z"}},
    "staticQueryHashes": []}
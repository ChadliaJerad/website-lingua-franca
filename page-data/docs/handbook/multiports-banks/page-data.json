{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/multiports-banks",
    "result": {"data":{"markdownRemark":{"id":"9b84157c-fc6c-5912-a375-3d5bf1a3aafc","excerpt":"This page describes Lingua Franca language constructs support more scalable programs by providing a compact syntax for ports that can send or receive over…","html":"<p>This page describes Lingua Franca language constructs support more scalable programs by providing a compact syntax for ports that can send or receive over multiple channels (called <strong>multiports</strong>) and multiple instances of a reactor class (called a <strong>bank of reactors</strong>). The examples given below include syntax of the C target for accessing the ports. Other targets use different syntax with target code, within the delimiters <code class=\"language-text\">{= ... =}</code>, but use the same syntax outside those delimiters.</p>\n<h1 id=\"multiports\" style=\"position:relative;\"><a href=\"#multiports\" aria-label=\"multiports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multiports</h1>\n<p>To declare an input or output port to be a <strong>multiport</strong>, use the following syntax:</p>\n<blockquote>\n<p><strong>input</strong>[<em>width</em>] <em>name</em>:<em>type</em>;\n<strong>output</strong>[<em>width</em>] <em>name</em>:<em>type</em>;</p>\n</blockquote>\n<p>where <em>width</em> is a positive integer. This can be given either as an integer literal or a parameter name. For targets that allow dynamic parametrization at runtime (like the C++ target), width can also be given by target code enclosed in <code class=\"language-text\">{=...=}</code>.</p>\n<p>For example, (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/multiport/MultiportToMultiport.lf\">MultiportToMultiport</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">target C;\nreactor Source {\n    output[4] out:int;\n    reaction(startup) -> out {=\n        for(int i = 0; i &lt; out_width; i++) {\n            SET(out[i], i);\n        }\n    =}\n}\nreactor Destination {\n    input[4] in:int;\n    reaction(in) {=\n        int sum = 0;\n        for (int i = 0; i &lt; in_width; i++) {\n            if (in[i]->is_present) sum += in[i]->value;\n        }\n        printf(\"Sum of received: %d.\\n\", sum);\n    =}\n}\nmain reactor MultiportToMultiport {\n    a = new Source();\n    b = new Destination();\n    a.out -> b.in;\n}</code></pre></div>\n<p>The <code class=\"language-text\">Source</code> reactor has a four-way multiport output and the <code class=\"language-text\">Destination</code> reactor has a four-way multiport input. These channels are connected all at once on one line, the second line from the last. Running this program produces:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Sum of received: 6.</code></pre></div>\n<p><strong>NOTE</strong>: In <code class=\"language-text\">Destination</code>, the reaction is triggered by <code class=\"language-text\">in</code>, not by some individual channel of the multiport input. Hence, it is important when using multiport inputs to test for presence of the input on each channel, as done above with the syntax <code class=\"language-text\">if (in[i]->is_present) ...</code>. An event on any one of the channels is sufficient to trigger the reaction.</p>\n<h2 id=\"sending-and-receiving-via-a-multiport\" style=\"position:relative;\"><a href=\"#sending-and-receiving-via-a-multiport\" aria-label=\"sending and receiving via a multiport permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sending and Receiving Via a Multiport</h2>\n<p>The source reactor specifies <code class=\"language-text\">out</code> as an effect of its reaction using the syntax <code class=\"language-text\">-> out</code>. This brings into scope of the reaction body a way to access the width of the port and a way to write to each channel of the port. It is also possible to test whether a previous reaction has set an output value and to read what that value is. The exact syntax for this depends on the target language. In the C target, the width is accessed with the variable <code class=\"language-text\">out_width</code>, and <code class=\"language-text\">out[i]</code> references the output channel to write to using the <code class=\"language-text\">SET</code> macro, as shown above. In addition, <code class=\"language-text\">out[i]->is_present</code> and <code class=\"language-text\">out[i]->value</code> are defined. For example, if we modify the above reaction as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source {\n    output[4] out:int;\n    reaction(startup) -> out {=\n        for(int i = 0; i &lt; out_width; i++) {\n            printf(\"Before SET, out[%d]->is_present has value %d\\n\", i, out[i]->is_present);\n            SET(out[i], i);\n            printf(\"AFTER set, out[%d]->is_present has value %d\\n\", i, out[i]->is_present);\n            printf(\"AFTER set, out[%d]->value has value %d\\n\", i, out[i]->value);\n        }\n    =}\n}</code></pre></div>\n<p>then we get the output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Before SET, out[0]->is_present has value 0\nAFTER set, out[0]->is_present has value 1\nAFTER set, out[0]->value has value 0\nBefore SET, out[1]->is_present has value 0\nAFTER set, out[1]->is_present has value 1\nAFTER set, out[1]->value has value 1\nBefore SET, out[2]->is_present has value 0\nAFTER set, out[2]->is_present has value 1\nAFTER set, out[2]->value has value 2\nBefore SET, out[3]->is_present has value 0\nAFTER set, out[3]->is_present has value 1\nAFTER set, out[3]->value has value 3\nSum of received: 6.</code></pre></div>\n<p>If you access <code class=\"language-text\">out[i]->value</code> before any value has been set, the result is\nundefined.</p>\n<p>In the Python target, multiports can be iterated on in a for loop (e.g., <code class=\"language-text\">for p in out</code>) or enumerated (e.g., <code class=\"language-text\">for i, p in enumerate(out)</code>) and the length of\nthe multiport can be obtained by using the <code class=\"language-text\">len()</code> (e.g., <code class=\"language-text\">len(out)</code>) expression.</p>\n<h2 id=\"parameterized-widths\" style=\"position:relative;\"><a href=\"#parameterized-widths\" aria-label=\"parameterized widths permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parameterized Widths</h2>\n<p>The width of a port may be given by a parameter. For example, the above <code class=\"language-text\">Source</code> reactor can be rewritten</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source(width:int(4)) {\n    output[width] out:int;\n    reaction(startup) -> out {=\n        for(int i = 0; i &lt; out_width; i++) {\n            SET(out[i], i);\n        }\n    =}\n}\n</code></pre></div>\n<p>In some targets such as the C++ target, parameters to the main reactor can be overwritten at the command line interface, allowing for dynamically scalable applications.</p>\n<h2 id=\"connecting-reactors-with-different-widths\" style=\"position:relative;\"><a href=\"#connecting-reactors-with-different-widths\" aria-label=\"connecting reactors with different widths permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connecting Reactors with Different Widths</h2>\n<p>Assume that the <code class=\"language-text\">Source</code> and <code class=\"language-text\">Destination</code> reactors above both use a parameter <code class=\"language-text\">width</code> to specify the width of their ports. Then the following connection is valid (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/multiport/MultiportToMultiport2.lf\">MultiportToMultiport2</a>)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor MultiportToMultiport2 {\n    a1 = new Source(width = 3);\n    a2 = new Source(width = 2);\n    b = new Destination(width = 5);\n    a1.out, a2.out -> b.in;\n}</code></pre></div>\n<p>The first three ports of <code class=\"language-text\">b</code> will received input from <code class=\"language-text\">a1</code>, and the last two ports will receive input from <code class=\"language-text\">a2</code>. Parallel composition can appear on either side of a connection. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    a1.out, a2.out -> b1.out, b2.out, b3.out;</code></pre></div>\n<p>If the total width on the left does not match the total width on the right, then a warning is issued. If the left side is wider than the right, then output data will be discarded. If the right side is wider than the left, then inputs channels will be absent.</p>\n<p>Any given port can appear only once on the right side of the <code class=\"language-text\">-></code> connection operator, so all connections to a multiport destination must be made in one single connection statement.</p>\n<h1 id=\"banks-of-reactors\" style=\"position:relative;\"><a href=\"#banks-of-reactors\" aria-label=\"banks of reactors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Banks of Reactors</h1>\n<p>Using a similar notation, it is possible to create a bank of reactors. For example, we can create a bank of four instances of <code class=\"language-text\">Source</code> and four instances of <code class=\"language-text\">Destination</code> and connect them as follows (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/multiport/MultiportToBankMultiport.lf\">MultiportToBankMultiport</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor BankToBankMultiport {\n    a = new[4] Source();\n    b = new[4] Destination();\n    a.out -> b.in;\n}</code></pre></div>\n<p>If the <code class=\"language-text\">Source</code> and <code class=\"language-text\">Destination</code> reactors have multiport inputs and outputs, as in the examples above, then a warning will be issued if the total width on the left does not match the total width on the right. For example, the following is balanced:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor BankToBankMultiport {\n    a = new[3] Source(width = 4);\n    b = new[4] Destination(width = 3);\n    a.out -> b.in;\n}</code></pre></div>\n<p>There will be three instances of <code class=\"language-text\">Source</code>, each with an output of width four, and four instances of <code class=\"language-text\">Destination</code>, each with an input of width 3, for a total of 12 connections.</p>\n<p>To distinguish the instances in a bank of reactors, the reactor can define a parameter called <strong>bank_index</strong> with any type that can be assigned a non-negative integer value (in C, for example, <code class=\"language-text\">int</code>, <code class=\"language-text\">size_t</code>, or <code class=\"language-text\">uint32_t</code> will all work). If such a parameter is defined for the reactor, then when the reactor is instanced in a bank, each instance will be assigned a number between 0 and <em>n</em>-1, where <em>n</em> is the number of reactor instances in the bank. For example, the following source reactor increments the output it produces by the value of <code class=\"language-text\">bank_index</code> on each reaction to the timer (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/multiport/BankToBank.lf\">BankToBank</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source(\n    bank_index:int(0)\n) {\n    timer t(0, 200 msec);\n    output out:int;\n    state s:int(0);\n    reaction(t) -> out {=\n        SET(out, self->s);\n        self->s += self->bank_index;\n    =}\n}</code></pre></div>\n<p>The width of a bank may also be given by a parameter, as in</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main reactor BankToBankMultiport(\n    source_bank_width:int(3),\n    destination_bank_width:int(4)\n) {\n    a = new[source_bank_width] Source(width = 4);\n    b = new[destination_bank_width] Destination(width = 3);\n    a.out -> b.in;\n}</code></pre></div>\n<h2 id=\"contained-banks\" style=\"position:relative;\"><a href=\"#contained-banks\" aria-label=\"contained banks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contained Banks</h2>\n<p>Banks of reactors can be nested. For example, note the following program:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">target C<span class=\"token punctuation\">;</span>\nreactor <span class=\"token function\">Child</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span>startup<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">=</span>\n        <span class=\"token function\">info_print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"My bank index is %d.\"</span><span class=\"token punctuation\">,</span> self<span class=\"token operator\">-></span>bank_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">=</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nreactor <span class=\"token function\">Parent</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nmain reactor <span class=\"token punctuation\">{</span>\n    p <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this program, the <code class=\"language-text\">Parent</code> reactor contains a bank of <code class=\"language-text\">Child</code> reactor instances\nwith a width of 2. In the main reactor, a bank of <code class=\"language-text\">Parent</code> reactors is\ninstantiated with a width of 2, therefore, creating 4 <code class=\"language-text\">Child</code> instances in the program in total.\nThe output of this program will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">My bank index is <span class=\"token number\">0</span>.\nMy bank index is <span class=\"token number\">1</span>.\nMy bank index is <span class=\"token number\">0</span>.\nMy bank index is <span class=\"token number\">1</span>.</code></pre></div>\n<p>Moreover, the bank index of a container (parent) reactor can be passed down to\ncontained (child) reactors. For example, note the following program:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">target C<span class=\"token punctuation\">;</span>\nreactor <span class=\"token function\">Child</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    parent_bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span>startup<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">=</span>\n        <span class=\"token function\">info_print</span><span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"My parent's bank index is %d.\"</span><span class=\"token punctuation\">,</span>\n            self<span class=\"token operator\">-></span>parent_bank_index\n            <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">=</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nreactor <span class=\"token function\">Parent</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span>parent_bank_index <span class=\"token operator\">=</span> bank_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\nmain reactor <span class=\"token punctuation\">{</span>\n    p <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In this example, the bank index of the <code class=\"language-text\">Parent</code> reactor is passed to the\n<code class=\"language-text\">parent_bank_index</code> parameter of the <code class=\"language-text\">Child</code> reactor instances.\nThe output from this program will be:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">My parent<span class=\"token string\">'s bank index is 0.\nMy parent'</span>s bank index is <span class=\"token number\">1</span>.\nMy parent<span class=\"token string\">'s bank index is 1.\nMy parent'</span>s bank index is <span class=\"token number\">0</span>.</code></pre></div>\n<p>Finally, members of contained banks of reactors can be individually addressed in\nthe body of reactions of the parent reactor if their input/output port appears\nin the reaction signature. For example, note the following program:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">target C<span class=\"token punctuation\">;</span>\nreactor <span class=\"token function\">Child</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    parent_bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    output out<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span>startup<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> out <span class=\"token punctuation\">{</span><span class=\"token operator\">=</span>\n        <span class=\"token function\">SET</span><span class=\"token punctuation\">(</span>out<span class=\"token punctuation\">,</span> self<span class=\"token operator\">-></span>parent_bank_index <span class=\"token operator\">+</span> self<span class=\"token operator\">-></span>bank_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token operator\">=</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nreactor <span class=\"token function\">Parent</span> <span class=\"token punctuation\">(</span>\n    bank_index<span class=\"token operator\">:</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    c <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Child</span><span class=\"token punctuation\">(</span>parent_bank_index <span class=\"token operator\">=</span> bank_index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">reaction</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">=</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> c_width<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">info_print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Received %d from child %d.\"</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>out<span class=\"token operator\">-></span>value<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">=</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nmain reactor <span class=\"token punctuation\">{</span>\n    p <span class=\"token operator\">=</span> new<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note the usage of <code class=\"language-text\">c_width</code>, which holds the width of the <code class=\"language-text\">c</code> bank of reactors.\nNote that this syntax is target-specific. For example, in the Python target,\n<code class=\"language-text\">len(c)</code> can be used to get the width of the bank, and <code class=\"language-text\">for p in c</code> or <code class=\"language-text\">for (i, p) in enumerate(c)</code> can be used to\niterate over the banks.</p>\n<h2 id=\"combining-banks-and-multiports\" style=\"position:relative;\"><a href=\"#combining-banks-and-multiports\" aria-label=\"combining banks and multiports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Combining Banks and Multiports</h2>\n<p>Banks of reactors may be combined with multiports (see <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/multiport/MultiportToBank.lf\">MultiportToBank</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source {\n    output[3] out:int;\n    reaction(startup) -> out {=\n        for(int i = 0; i &lt; out_width; i++) {\n            SET(out[i], i);\n        }\n    =}\n}\nreactor Destination(\n    bank_index:int(0)\n) {\n    input in:int;\n    reaction(in) {=\n        printf(\"Destination %d received %d.\\n\", self->bank_index, in->value);\n    =}\n}\n\nmain reactor MultiportToBank {\n    a = new Source();\n    b = new[3] Destination();\n    a.out -> b.in;\n}</code></pre></div>\n<p>The three outputs from the <code class=\"language-text\">Source</code> instance <code class=\"language-text\">a</code> will be sent, respectively, to each of three instances of <code class=\"language-text\">Destination</code>, <code class=\"language-text\">b[0]</code>, <code class=\"language-text\">b[1]</code>, and <code class=\"language-text\">b[2]</code>.</p>\n<p>The reactors in a bank may themselves have multiports. In all cases, the number of ports on the left of a connection must match the number on the right, unless the ones on the left are iterated, as explained next.</p>\n<h1 id=\"broadcast-connections\" style=\"position:relative;\"><a href=\"#broadcast-connections\" aria-label=\"broadcast connections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Broadcast Connections</h1>\n<p>Occasionally, you will want to have fewer ports on the left of a connection and have their outputs used repeatedly to broadcast to the ports on the right. In the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/concurrent/ThreadedThreaded.lf\">ThreadedThreaded</a> example, the outputs from an ordinary port are broadcast to the inputs of all instances of a bank of reactors:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Source {\n\toutput out:int;\n\treaction(startup) -> out {=\n\t\tSET(out, 42);\n\t=}\n}\nreactor Destination {\n\tinput in:int;\n\treaction(in) {=\n\t\t...\n\t=}\n}\nmain reactor ThreadedThreaded(width:int(4)) {\n\ta = new Source();\n\td = new[width] Destination();\n\t(a.out)+ -> d.in;\n}</code></pre></div>\n<p>The syntax <code class=\"language-text\">(a.out)+</code> means “repeat the output port <code class=\"language-text\">a.out</code> one or more times as needed to supply all the input ports of <code class=\"language-text\">d.in</code>.” The content inside the parentheses can be a comma-separated list of ports, the ports inside can be ordinary ports or multiports, and the reactors inside can be ordinary reactors or banks of reactors. In all cases, the number of ports inside the parentheses on the left must divide the number of ports on the right.</p>\n<h1 id=\"interleaved-connections\" style=\"position:relative;\"><a href=\"#interleaved-connections\" aria-label=\"interleaved connections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interleaved Connections</h1>\n<p>Sometimes, we don’t want to broadcast messages to all reactors, but need more fine-grained control as to which reactor within a bank receives a message. If we have separate source and destination reactors, this can be done by combining multiports and banks as was shown in <a href=\"#Combining-Banks-and-Multiports\">Combining Banks and Multiports</a>. Setting a value on the index N of the output multiport, will result in a message to the Nth reactor instance within the destianation bank. However, this pattern gets slightly more complicated, if we want to exchange addressable messages between instances of the same bank. This pattern is shown in the <a href=\"https://github.com/lf-lang/lingua-franca/blob/master/example/C/src/Patterns/FullyConnected_01_Addressable.lf\">FullyConnected_01_Addressable</a> example, which is simplified below:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reactor Node(\n    num_nodes: size_t(4),\n    bank_index: int(0)\n) {\n    input[num_nodes] in: int;\n    output[num_nodes] out: int;\n\n    reaction (startup) -> out {=\n     \tSET(out[1], 42);\n    =}\n\n    reaction (in) {=\n        ...\n    =}\n}\n\nmain reactor(num_nodes: size_t(4)) {\n    nodes = new[num_nodes] Node(num_nodes=num_nodes);\n    nodes.out -> interleaved(nodes.in);\n}</code></pre></div>\n<p>In the above program, four instance of <code class=\"language-text\">Node</code> are created, and, at startup, each instance sends 42 to its second (index 1) output channel. The result is that the second bank member (<code class=\"language-text\">bank_index</code> 1) will receive the number 42 on each input channel of its multiport input. The 0-th channel will receive from <code class=\"language-text\">bank_index</code> 0, the 1-th channel from <code class=\"language-text\">bank_index</code> 1, etc. In effect, the choice of output channel specifies the destination reactor in the bank, and the input channel specifies the source reactor.</p>\n<p>This style of connection is accomplished using the new keyword <strong>interleaved</strong> in the connection. Normally, a port reference such as <code class=\"language-text\">nodes.out</code> where <code class=\"language-text\">nodes</code> is a bank and <code class=\"language-text\">out</code> is a multiport, would list all the individual ports by first iterating over the banks and then the ports. If we consider the tuple (b,p) to denote the index b within the bank and the index p within the multiport, then the following list is created: (0,0), (0,1), (0,2), (0,3), (1,0), (1,1), (1,2), (1,3), (2,0), (2,1), (2,2), (2,3), (3,0), (3,1), (3,2), (3,3). However, if we use <code class=\"language-text\">interleaved(nodes.out)</code> instead, the connection logic will iterate over the ports first and then the banks, creating the following list: (0,0), (1,0), (2,0), (3,0), (0,1), (1,1), (2,1), (3,1), (0,2), (1,2), (2,2), (3,2), (0,3), (1,3), (2,3), (3,3). By combining a normal port reference with a interleaved reference, we can construct a fully connected network. The figure below visualizes this pattern and shows a desugared version constructed without banks or multiports:</p>\n<p><img src=\"https://user-images.githubusercontent.com/6460123/127457209-1ce3339e-53c1-4ac8-a379-5a8fbb5940d3.png\" alt=\"Addressable\"></p>\n<p>If we would use a normal connection instead <code class=\"language-text\">nodes.out -> nodes.in;</code>, then the following pattern would be created:</p>\n<p><img src=\"https://user-images.githubusercontent.com/6460123/127457454-8e15d222-c9da-4a5b-8182-32f86546baa0.png\" alt=\"Naive\"></p>\n<p>Effectively, this connects each reactor instance to itself, which isn’t very useful.</p>","headings":[{"value":"Multiports","depth":1},{"value":"Sending and Receiving Via a Multiport","depth":2},{"value":"Parameterized Widths","depth":2},{"value":"Connecting Reactors with Different Widths","depth":2},{"value":"Banks of Reactors","depth":1},{"value":"Contained Banks","depth":2},{"value":"Combining Banks and Multiports","depth":2},{"value":"Broadcast Connections","depth":1},{"value":"Interleaved Connections","depth":1}],"frontmatter":{"permalink":"/docs/handbook/multiports-banks","title":"Multiports and Banks","oneline":"Multiports and Banks of Reactors.","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Language Specification","oneline":"Language Specification for Lingua Franca.","permalink":"/docs/handbook/language-specification"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Future Proof Package/Import System","oneline":"A future proof package and import system","permalink":"/docs/handbook/proof-import"}}}},"pageContext":{"id":"0-multiports-and-banks","slug":"/docs/handbook/multiports-banks","repoPath":"/packages/documentation/copy/en/topics/language-specification/Multiports and Banks.md","previousID":"6b43d1de-7911-5e46-9100-2f494e455e3a","lang":"en","modifiedTime":"2022-02-03T19:46:10.430Z"}},
    "staticQueryHashes": []}
{
    "componentChunkName": "component---src-templates-documentation-tsx",
    "path": "/docs/handbook/termination",
    "result": {"data":{"markdownRemark":{"id":"a39a2bbf-52f8-5923-ae64-a2eae06c668e","excerpt":"There are a number of subtleties associated with the termination of Lingua Franca programs, particularly with federated execution. For the purposes of thisâ€¦","html":"<p>There are a number of subtleties associated with the termination of Lingua Franca programs, particularly with federated execution. For the purposes of this discussion, <strong>tag</strong> refers to the tuple (<strong>logical time</strong>, <strong>microstep</strong>).</p>\n<p>There are several ways to terminate a program:</p>\n<ul>\n<li><strong>Timeout</strong>: The program specifies the last logical time at which reactions should be triggered.</li>\n<li><strong>Starvation</strong>: At the conclusion of some tag, there are no events in the event queue at future tags.</li>\n<li><strong>Stop request</strong>: Some reaction requests that the program terminate.</li>\n<li><strong>External signal</strong>: Program is terminated externally with control-C or <code class=\"language-text\">kill</code>.</li>\n</ul>\n<p>We address each of these in turn.</p>\n<h2 id=\"timeout\" style=\"position:relative;\"><a href=\"#timeout\" aria-label=\"timeout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Timeout</h2>\n<p>The target property <code class=\"language-text\">timeout</code> specifies the last logical time at which reactions should be triggered. The last invocation of reactions will be at tag (<code class=\"language-text\">timeout</code>, 0). The subtleties:</p>\n<ul>\n<li>\n<p><strong>Schedule</strong>: Any invocation of <code class=\"language-text\">schedule</code> that specifies a logical time greater than the timeout value is ignored. No event gets scheduled. Moreover, if <code class=\"language-text\">schedule</code> is invoked at logical time equal to <code class=\"language-text\">timeout</code>, then it is again ignored because that would have resulted in an event with tag (<code class=\"language-text\">timeout</code>, 1), which is greater than the final tag.</p>\n</li>\n<li>\n<p><strong>Shutdown reactions</strong>: Reactions that are triggered by <code class=\"language-text\">shutdown</code> will be triggered at tag (<code class=\"language-text\">timeout</code>, 0). There may be many other reactions triggered at that same tag, and a shutdown reaction may produce outputs causing other reactions to be triggered, so there is no assurance that shutdown reactions are invoked last. However, if a shutdown reaction is the last reaction in a reactor, then it is assured of being the last reaction invoked <em>in that reactor</em> at that final tag.</p>\n</li>\n<li>\n<p><strong>After</strong>: If at logical time <em>t</em> a reaction sends an output over connection using the keyword <code class=\"language-text\">after</code> with value <em>d</em> >= 0, and <em>t</em> + <em>d</em> ><code class=\"language-text\">timeout</code>, then the output is dropped. No event gets scheduled. If <em>d</em> = 0 and <em>t</em> = <code class=\"language-text\">timeout</code>, the output is also dropped because that would have resulted in an event with tag (<code class=\"language-text\">timeout</code>, 1), which is greater than the final tag. In a <strong>federated</strong> execution, no message is launched into the network if <em>t</em> + <em>d</em> ><code class=\"language-text\">timeout</code>.</p>\n</li>\n<li>\n<p><strong>Physical connections</strong>: A connection using the syntax <code class=\"language-text\">~></code> specifies that the tag at the receiving end of the connection will be based on the physical time at which the message is received. See [[Physical Connections]] for the specification for how the tag is assigned at the receiving end. If the tag assigned at the receiving end is greater than (<code class=\"language-text\">timeout</code>, 0), then the message is lost. Hence, <strong>messages sent near the <code class=\"language-text\">timeout</code> time are likely to be lost!</strong></p>\n</li>\n</ul>\n<h2 id=\"starvation\" style=\"position:relative;\"><a href=\"#starvation\" aria-label=\"starvation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Starvation</h2>\n<p>If the target property <code class=\"language-text\">keepalive</code> is not specified or is set to <code class=\"language-text\">false</code> (the default), then a Lingua Franca program will exit after completing a logical tag if there are no future events scheduled. If there is a <strong>timer</strong> anywhere in the program, then this condition never occurs. There is always a future event scheduled (unless the <code class=\"language-text\">timeout</code> has been reached). If there is a <strong>physical action</strong> anywhere in the program (and there is no timer), then you will need to set <code class=\"language-text\">keepalive</code> to true to prevent the program from exiting while waiting for some external stimulus.</p>\n<p>Starvation termination is tricky to implement for federated execution, particularly when physical connections are used. It requires developing a distributed consensus. One way to accomplish this is for each federate to send a <strong>QUEUE_EMPTY</strong> message to the RTI whenever its event queue is empty. The message will need to include a count of the total number of messages it has sent or received on each direct connection to another federate. When the RTI receives such a message from all federates, and the number of messages sent and received on each direct connection match, then the RTI can broadcast a shutdown message.</p>\n<p>A decentralized version of the same consensus is more challenging but will be necessary if there is no RTI running. <strong>FIXME</strong>: Proposals are welcome here.</p>\n<h2 id=\"stop-request\" style=\"position:relative;\"><a href=\"#stop-request\" aria-label=\"stop request permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stop Request</h2>\n<p>If a reaction calls <code class=\"language-text\">request_stop</code>, then it is requesting that the program cease execution as soon as possible. In a non-federated execution, this cessation can occur in the next microstep. The current tag will be completed as normal. Then the tag will be advanced by one microstep, and reactions triggered by <code class=\"language-text\">shutdown</code> will be executed, along with any other reactions with triggers at that tag, with all reactions executed in precedence order.</p>\n<p>In a federated execution, things are more complicated. In general, it is not possible to cease execution in the next microstep because this would mean that every federate has a communication channel to every other with delay equal to one microstep. This this does not create a causality loop, but it means that all federates have to advance time in lockstep, which creates a global barrier synchronization that will likely kill performance. It will also make decentralized coordination impossible because the safe-to-process (STP) threshold for all federates will explode to infinity.</p>\n<p>For <strong>centralized coordination</strong>, when a reaction in a federate calls <code class=\"language-text\">stop</code>, the federate sends a <strong>STOP_REQUEST</strong> message to the RTI with its current timestamp <em>t</em> as a payload. It then waits for a <strong>STOP_GRANTED</strong> message with a timestamp payload <em>s</em>. During this wait, it must respond to ** STOP_REQUEST** incoming messages from the RTI (and all other messages from the RTI). (It should be possible to complete the current logical time while waiting.) If <em>s</em> > <em>t</em>, then it sets <code class=\"language-text\">timeout</code> = <em>s</em> and continues executing, using the timeout mechanism (see above) to stop. If <em>s</em> = <em>t</em>, then it completes the current tag as normal but schedules on shutdown phase to occur one microstep later, as in the unfederated case.</p>\n<p>When the RTI receives a <strong>STOP_REQUEST</strong> message from a federate, it forwards it to all other federates and waits for a reply from all. Each reply will have a timestamp payload. The RTI chooses <em>s</em>, the largest of these timestamps, and sends a <strong>STOP_GRANTED</strong> message to all federates with payload <em>s</em>.</p>\n<p>When a federate receives a <strong>STOP_REQUEST</strong> message, it replies with its current logical time <em>t</em> and waits for a <strong>STOP_GRANTED</strong> message from the RTI, blocking all execution during the wait. When it gets the reply with payload <em>s</em>, if <em>s</em> > <em>t</em>, then it sets <code class=\"language-text\">timeout</code> = <em>s</em> and continues executing, using the timeout mechanism (see above) to stop. If <em>s</em> = <em>t</em>, then it completes the current tag as normal but schedules on shutdown phase to occur one microstep later, as in the unfederated case.</p>\n<h2 id=\"external-signal\" style=\"position:relative;\"><a href=\"#external-signal\" aria-label=\"external signal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>External Signal</h2>\n<p>Each federate and the RTI should catch external signals to shut down in an orderly way.</p>\n<p>When a federate gets such an external signal (e.g. control-C), it should send a <strong>RESIGN</strong> message to the RTI and an <strong>EOF</strong> (end of file) on each socket connection to another federate. It should then close all sockets and shut down. The RTI and all other federates should continue running until some other termination condition occurs.</p>\n<p>When the RTI gets such an external signal, it should broadcast a <strong>STOP_REQUEST</strong> message to all federates, wait for their replies (with a timeout in case the federate or the network has failed), choose the maximum timestamp <em>s</em> on the replies, broadcast a <strong>STOP_GRANTED</strong> message to all federates with payload <em>s</em>, and wait for <strong>LOGICAL_TIME_COMPLETE</strong> messages as above.</p>","headings":[{"value":"Timeout","depth":2},{"value":"Starvation","depth":2},{"value":"Stop Request","depth":2},{"value":"External Signal","depth":2}],"frontmatter":{"permalink":"/docs/handbook/termination","title":"Termination","oneline":"Terminating a Lingua Franca execution.","preamble":""}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Target Specification","oneline":"The target specification in Lingua Franca.","permalink":"/docs/handbook/target-specification"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"C Reactors","oneline":"Writing reactors using the C target in Lingua Franca.","permalink":"/docs/handbook/c-reactors"}}}},"pageContext":{"id":"3-termination","slug":"/docs/handbook/termination","repoPath":"/packages/documentation/copy/en/reference/Termination.md","previousID":"062ea964-c57a-5cd6-8a49-25f895d2d328","nextID":"c449a37c-ee78-5d84-93d7-25359468889c","lang":"en","modifiedTime":"2022-03-30T14:09:54.043Z"}},
    "staticQueryHashes": []}
---
title: "Target Specification"
layout: docs
permalink: /docs/handbook/target-specification
oneline: "The target specification in Lingua Franca."
preamble: >
---

Every Lingua Franca program begins with a statement of this form:

```lf
    target <name> <parameters>
```

The `<name>` gives the name of some Lingua Franca target language, which is the language in which reactions are written. This is also the language of the program(s) generated by the Lingua Franca compiler. The target languages currently supported are [**C**](c-reactors), [**C++**](cpp-reactors), [**Python**](python-reactors), [**TypeScript**](typescript-reactors), and[**Rust**](rust-reactors).

# Summary of Parameters

A target specification may have optional parameters, the names and values of which depend on which specific target you are using. Each parameter is a key-value pair, where the supported keys are some subset of the following:

- [**build**](#build): A command to execute after code generation instead of the default compile command.
- [**cmake**](#cmake): Whether to use cmake for building.
- [**cmake-include**](#cmake): List of paths to cmake files to guide compilation.
- [**compiler**](#compiler): A string giving the name of the target language compiler to use.
- [**fast**](#fast): A boolean specifying to execute as fast as possible without waiting for physical time to match logical time.
- [**files**](#files): An array of paths to files or directories to be copied to the directory that contains the generated sources.
- [**flags**](#flags): An arrays of strings giving options to be passed to the target compiler.
- [**logging**](#logging): An indicator of how much information to print when executing the program.
- [**no-compile**](#no-compile): If true, then do not invoke a target language compiler. Just generate code.
- [**protobufs**](#protobufs): An array of .proto files that are to be compiled and included in the generated code.
- [**threading**](#threading): Whether to use multiple threads.
- [**timeout**](#timeout): A time value (with units) specifying the logical stop time of execution. See [[Termination]].
- [**workers**](#workers): If using multiple threads, how many worker threads to create.

Not all targets support all target parameters. The full set of target parameters supported by the $target-language$ target is:

```lf-c
target C {
    build: <string>,
    cmake: <true or false>,
    cmake-include: <string or list of strings>,
    compiler: <string>,
    fast: <true or false>,
    files: <string or list of strings>,
    flags: <string or list of strings>,
    logging: <error, warning, info, log, debug>,
    no-compile: <true or false>,
    protobufs: <string or list of strings>,
    timeout: <time>,
    threading: <true or false>,
    workers: <non-negative integer>,
};
```

```lf-cpp
FIXME
```

```lf-py
FIXME
```

```lf-ts
FIXME
```

```lf-rs
FIXME
```

<div class="lf-c">
For example:

```lf-c
target C {
    cmake: false,
    compiler: "cc",
    flags: "-O3",
    fast: true,
    logging: log,
    timeout: 1 secs,
};
```

The comma on the last parameter is optional, as is the semicolon on the last line.

This specifies to use compiler `cc` instead of the default `gcc`, to use optimization level 3, to execute as fast as possible, and to exit execution when logical time has advanced to 10 seconds. Note that all events at logical time 10 seconds greater than the starting logical time will be executed.

</div>

A target may support overriding the target parameters on the [command line](#command-line-overrides) when invoking the compiled program.

## build

<div class="lf-c">

A command to execute after code generation instead of the default compile command. This is either a single string or an array of strings. The specified command(s) will be executed an environment that has the following environment variables defined:

- `LF_CURRENT_WORKING_DIRECTORY`: The directory in which the command is invoked.
- `LF_SOURCE_DIRECTORY`: The directory containing the .lf file being compiled.
- `LF_SOURCE_GEN_DIRECTORY`: The directory in which generated files are placed.
- `LF_BIN_DIRECTORY`: The directory into which to put binaries.

The command will be executed in the same directory as the `.lf` file being compiled. For example, if you specify

```lf-c
target C {
    build: "./compile.sh Foo"
}
```

then instead of invoking the C compiler after generating code, the code generator will invoke your `compile.sh` script, which could look something like this:

```
#!/bin/bash
# Build the generated code.
cd ${LF_SOURCE_GEN_DIRECTORY}
cmake .
make

# Move the executable to the bin directory.
mv $1 ${LF_BIN_DIRECTORY}

# Invoke the executable.
${LF_BIN_DIRECTORY}/$1

# Plot the results, which have appeared in the src-gen directory.
gnuplot ${LF_SOURCE_DIRECTORY}/$1.gnuplot
open $1.pdf
```

The first few lines of this script do the same thing that is normally done when there is no `build` option in the target. Specifically, they use `cmake` to create a makefile, invoke `make`, and then move the executable to the `bin` directory. The next line, however, gives new functionality. It executes the compiled code! The final two lines assume that the program has produced a file with data to be plotted and use `gnuplot` to plot the data. This requires, of course, that you have `gnuplot` installed, and that there is a file called `Foo.gnuplot` in the same directory as `Foo.lf`. The file `Foo.gnuplot` contains the commands to plot the data, and might look something like the following:

```
set title 'My Title'
set xrange [0:3]
set yrange [-2:2]
set xlabel "Time (seconds)"
set terminal pdf size 5, 3.5
set output 'Foo.pdf'
plot 'mydata1.data' using 1:2 with lines, \
     'mydata2.data' using 1:2 with lines
```

This assumes that your program has written two files, `mydata1.data` and `mydata2.data` containing two columns, time and value.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## cmake

<div class="lf-c">

```lf-c
target C {
    cmake: <true or false>
};
```

This will enable or disable the CMake-based build system (the default is `true`). Enabling the CMake build system will result in a `CMakeLists.txt` being generated in the `src-gen` directory. This `CMakeLists.txt` is then used when `cmake` is invoked by the LF runtime (either the `lfc` or the IDE). Alternatively, the generated program can be built manually. To do so, in the `src-gen/ProgramName` directory, run:

```
mkdir build && cd build
cmake ../
make
```

If `cmake` is disabled, `gcc` is directly invoked after code generation by default. In this case, additional target properties, such as [compiler](#compiler) and [flags](#flags) can be used to gain finer control over the compilation process.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## cmake-include

<div class="lf-c">

```
target C {
    cmake-include: ["relative/path/to/foo.txt", "relative/path/to/bar.txt", ...]
};
```

This will optionally append additional custom CMake instructions to the generated `CMakeLists.txt`, drawing these instructions from the specified text files (e.g, `foo.txt`). The specified files are resolved using the same file search algorithm as used for the [files](#files) target parameter. Those files will be copied into the `src-gen` directory that contains the generated sources. This is done to make the generated code more portable (a feature that is useful in [federated execution](/docs/handbook/distributed-execution).

The cmake-include target property can be used, for example, to add dependencies on various packages (e.g., by using the [`find_package`](https://cmake.org/cmake/help/latest/command/find_package.html) and [`target_link_libraries`](https://cmake.org/cmake/help/latest/command/target_link_libraries.html) commands). [CMakeInclude.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/CMakeInclude.lf) is an example that uses this feature. A more sophisticated example of the usage of this target parameter can be found in [Rhythm.lf](https://github.com/lf-lang/lingua-franca/blob/master/example/C/src/Rhythm/Rhythm.lf).

A CMake variable called `${LF_MAIN_TARGET}` can be used in the included text file(s) for convenience. This variable will contain the name of the CMake target (i.e., the name of the main reactor). For example, a `foo.txt` file can contain:

```
find_package(m REQUIRED) # Finds the m library

target_link_libraries( ${LF_MAIN_TARGET} m ) # Links the m library
```

`foo.txt` can then be included:

```
target C {
    cmake-include: "foo.txt"
};
```

In this case, "foo.txt" is in the same `src` folder as the main `.lf` file.

**Note**: For a general tutorial on finding packages in CMake, see [this](https://cmake.org/cmake/help/latest/command/find_package.html) external documentation entry. For a list of CMake find modules, see [this](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find-modules).

The `cmake-include` parameter works in conjunction with the $import$ statement. If any imported `.lf` file has `cmake-include` among its target properties, the specified text files will be appended to the current list of `cmake-include`s. These files will be resolved relative to the imported `.lf` file using the same search procedure as for the [files](#files) parameter. This helps resolve dependencies in imported reactors automatically and makes the code more modular. [DistributedCMakeInclude.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeInclude.lf) is a test that uses this feature.

**Note**: For [federated execution](/docs/handbook/distributed-execution), both `cmake-include` and [files](#files) are kept separate for each federate as much as possible. This means that if one federate is imported, or uses an imported reactor that other federates don't use, it will only have access to `cmake-include`s and `files` defined in the main `.lf` file, plus the selectively imported `.lf` files. [DistributedCMakeIncludeSeparateCompile.lf](https://github.com/lf-lang/lingua-franca/blob/master/test/C/src/target/DistributedCMakeIncludeSeparateCompile.lf) is a test that demonstrates this feature.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## compiler

<div class="lf-c">

This parameter is a string giving the name of the target language compiler to use.
It is used only when [cmake](#cmake) is set to `false`. For example:

```lf-c
target C {
    cmake: false,
    compiler: "cc",
};
```

The `compiler` option here specifies to use `cc` rather than `gcc`.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## fast

By default, the execution of a Lingua Franca program is slowed down, if necessary, so that logical time does not elapse faster than physical time. If you wish to execute the program as fast as possible without this constraint, then specify the `fast` target parameter with value `true`.

## files

<div class="lf-c">

The `files` target parameter specifies array of files or directories to be copied to the directory that contains the generated sources.

```lf-c
target C {
    files: ["file1", "file2", ...]
}
```

The lookup procedure for these files and directories is as follows:

1- Search in the directory containing the `.lf` file that has the **target** directive.

2- If not found, search in `LF_CLASSPATH`.

3- If still not found, search in `CLASSPATH`.

4- If still not found, search for the file as a resource. Specifically, if a file begins with a forward slash `/`, then the path is assumed to be relative to the root directory of the Lingua Franca source tree. For example, if you wish to use audio on a Mac, you can specify:

```
target C {
    files: ["/lib/C/util/audio_loop_mac.c", "/lib/C/util/audio_loop.h"]
}
```

Your preamble code can then include these files, for example:

```
preamble {=
    #include "audio_loop_mac.c"
=}
```

Your reactions can then invoke functions defined in that `.c` file.

Sometimes, you will need access to these files from target code in a reaction. For the C target (at least), the generated program will contain a line like this:

```
    #define TARGET_FILES_DIRECTORY "path"
```

where `path` is the full path to the directory containing these files. This can be used in reactions, for example, to read those files.

Moreover, the `files` target specification works in conjunction with the $import$ statement. If a `.lf` file is imported and has designated supporting files using the `files` target parameter, those files will be resolved relative to that `.lf` file and copied to the directory that contains the generated sources. This is done to make code that imports other `.lf` files more modular. [Rhythm.lf](https://github.com/lf-lang/lingua-franca/blob/master/example/C/src/Rhythm/Rhythm.lf) is an example that demonstrates most of these features.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## flags

<div class="lf-c">

This parameter is a list of strings giving additional arguments to pass to the target language compiler.
It is used only when [cmake](#cmake) is set to `false`. For example:

```lf-c
target C {
    cmake: false,
    flags: ["-g", "-I/usr/local/include", "-L/usr/local/lib", "-lpaho-mqtt3c"],
};
```

The `flags` option specifies to include debug information in the compiled code (`-g`); a directory to search for include files (`-I/usr/local/include`); a directory to search for library files (`-L/usr/local/lib`); a library to link with (`-lpaho-mqtt3c`, which will link with file `libpaho-mqtt3c.so`).

**Note**: Using the `flags` standard parameter when `cmake` is enabled is strongly discouraged, although supported. Flags are compiler-specific, and thus interfere with CMake's ability to find the most suitable compiler for each platform. In a similar fashion, we recommend against the use of the `compiler` standard parameter for the same reason. A better solution is to provide a `cmake-include` file, as described next.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## logging

<div class="lf-c">

By default, when executing a generated Lingua Franca program, error messages, warnings, and informational messages are printed to standard out. You can get additional information printed by setting the `logging` parameter to `LOG` or `DEBUG` (or `log` or `debug`). The latter is more verbose. If you set the `logging` parameter to `warn`, then warnings and errors will be printed, but informational messages will not (e.g. message produced using the `info_print` utility function). If you set `logging` to `error`, then warning messages will also not be printed.

The C target also supports [tracing](/docs/handbook/tracing), which outputs binary traces of an execution rather than human-readable text and is designed to have minimal impact on performance.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## no-compile

<div class="lf-c">

If true, then do not invoke a target language compiler nor cmake. Just generate code.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## protobufs

Protobufs is a serialization protocol by which data in a target language can be copied over the network to a remote location. The `protobufs` target parameter gives an array of .proto files that are to be compiled and included in the generated code.

<div class="lf-c warning">

**FIXME:** Do we have an example of this to point to?

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>

## threading

<div class="lf-c lf-cpp">

If threading is turned on (the default), then the generated code will use a target platform thread library and generate multi-threaded code. This can transparently execute execute reactions that have no dependence on one another in parallel on multiple cores. By default, threading is turned on, and the `workers` property is set to 0, which means that the number of workers is determined by the runtime system. Typically, it will be set to the number of cores on the machine running the code. To use a different number of worker threads, the following target parameters can be specified:

```lf-c
target C {
    threading: true,
    workers: <integer>,
};
```

```lf-cpp
target Cpp {
    threading: true,
    workers: <integer>,
};
```

A reasonable choice for the number of workers is the number of cores on the target machine. The default is `0`, which means that the runtime engine is free to choose the number of worker threads to use. Currently, the C target defaults to using only a single worker thread.

If threading is disabled (by setting `threading` to `false`), then no thread library is used, and the `schedule()` function is not thread safe. This setting is incompatible with asynchronously scheduling any physical actions and hence this parameter will be ignored for programs that have physical actions.

</div>

<div class="lf-py lf-ts">

The $target-language$ target does not support multithreaded execution.

</div>

<div class="lf-rs warning">

**FIXME:** Does this target support this?

</div>

## timeout

A time value (with units) specifying the logical stop time of execution. See [Termination](/docs/handbook/termination).

## workers

See [threading](#threading).

# Command-Line Arguments

<div class="lf-c">

The generated C program understands the following command-line arguments, each of which has a short form (one character) and a long form:

- `-f, --fast [true | false]`: Specifies whether to wait for physical time to match logical time. The default is `false`. If this is `true`, then the program will execute as fast as possible, letting logical time advance faster than physical time.
- `-o, --timeout <duration> <units>`: Stop execution when logical time has advanced by the specified _duration_. The units can be any of nsec, usec, msec, sec, minute, hour, day, week, or the plurals of those.
- `-w, --workers <n>`: Executed using <n> worker threads if possible. This option is ignored in the single-threaded version. That is, it is ignored if a `threading` option was given in the target properties with value `false`.
- `-i, --id <n>`: The ID of the federation that this reactor will join.

Any other command-line arguments result in printing the above information.

</div>

<div class="lf-cpp lf-py lf-ts lf-rs warning">

**FIXME:** Does this target support this?

</div>
